<html>

<head>
    <style>
        img {
            border: 1px solid black;
        }

        canvas {
            background-color: black;
        }

        .highlight {
            background-color: green;
        }

        .assetItem { position: relative; display: inline-block; margin: 2px; }
        .assetItem img { display: block; }
        .deleteBtn { position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.6); color: #fff; border: none; border-radius: 2px; cursor: pointer; font-size: 12px; line-height: 1; padding: 2px 4px; }
    </style>
</head>

<body>

    <div><a href="https://unsplash.com/s/photos/werte?license=free" target="unsplash">Background</a>: <input
            id="inputBackgroundURL" type="text" size="50" data-force-imageload><input type="file"
            data-image-target="inputBackgroundURL" /><span id="spanBackgroundPosition"></span><button id="btnPromptBackground" title="Generate with prompt">P</button><span id="spanPromptBackground" style="display:none;"> Prompt: <input id="inputPromptBackground" type="text" size="40" placeholder="Describe background..."><button id="btnGenerateBackground" title="Generate background image">Generate</button> <label title="Include Background as reference"><input id="chkBgBackground" type="checkbox"> Background</label> <label title="Include Pose as reference"><input id="chkBgPose" type="checkbox"> Pose</label> <label title="Include SecondImage as reference"><input id="chkBgSecond" type="checkbox"> SecondImage</label> <label title="Include ThirdImage as reference"><input id="chkBgThird" type="checkbox"> ThirdImage</label></span></div>
    <div><a href="https://library.techsmith.com/en/camtasia/assets/Graphic/Photo">SecondImage</a>: <input
            id="inputSecondURL" type="text" size="50" data-force-imageload><input type="file"
            data-image-target="inputSecondURL" /><span id="spanSecondPosition"></span><button id="btnPromptSecond" title="Generate with prompt">P</button><span id="spanPromptSecond" style="display:none;"> Prompt: <input id="inputPromptSecond" type="text" size="40" placeholder="Describe second image..."><button id="btnGenerateSecond" title="Generate second image">Generate</button> <label title="Apply chroma key to SecondImage"><input id="chkSecondMask" type="checkbox" checked> Mask</label> <button id="btnSecondSample" title="Sample key color from borders of SecondImage">Sample</button> Color: <input id="inputSecondKeyColor" type="color" value="#ff00ff"> Tol: <input id="inputSecondTolerance" type="range" min="-1" max="255" value="0"> Soft: <input id="inputSecondSoftness" type="range" min="-1" max="255" value="0"></span></div>
    <div>ThirdImage: <input id="inputThirdURL" type="text" size="50" data-force-imageload><input type="file"
            data-image-target="inputThirdURL" /><span id="spanThirdPosition"></span><button id="btnPromptThird" title="Generate with prompt">P</button><span id="spanPromptThird" style="display:none;"> Prompt: <input id="inputPromptThird" type="text" size="40" placeholder="Describe third image..."><button id="btnGenerateThird" title="Generate third image">Generate</button> <label title="Apply chroma key to ThirdImage"><input id="chkThirdMask" type="checkbox" checked> Mask</label> <button id="btnThirdSample" title="Sample key color from borders of ThirdImage">Sample</button> Color: <input id="inputThirdKeyColor" type="color" value="#ff00ff"> Tol: <input id="inputThirdTolerance" type="range" min="-1" max="255" value="0"> Soft: <input id="inputThirdSoftness" type="range" min="-1" max="255" value="0"></span></div>
    <div>Pose: <input id="inputPose" step="1" type="number" min="0" max="30" data-force-imageload /><button
            title="chaos" onclick="inputPoseURL.value=''; if (typeof inputPoseKeyColor!=='undefined'){ inputPoseKeyColor.dataset.sampled=''; } randomizeInputByMinMax(inputPose, true); loadImagesAndRender()">c</button><span
            id="spanPoses"></span><span id="spanPosesPosition"></span><button id="btnPromptPose" title="Generate with prompt">P</button><span id="spanPromptPose" style="display:none;"> Prompt: <textarea id="inputPromptPose" rows="4" cols="80" placeholder="Describe pose edit...">Using the provided image of a man in a suit, give him a magic hat. Ensure the man's face and features remain completely unchanged. The background has to be #ff00ff.</textarea><button id="btnGeneratePose" title="Generate pose image">Generate</button> <label title="Apply chroma key to pose"><input id="chkPoseMask" type="checkbox" checked> Mask</label> <button id="btnPoseSample" title="Sample key color from borders of pose">Sample</button> Color: <input id="inputPoseKeyColor" type="color" value="#ff00ff"> Tol: <input id="inputPoseTolerance" type="range" min="-1" max="255" value="0"> Soft: <input id="inputPoseSoftness" type="range" min="-1" max="255" value="0"></span><input id="inputPoseURL" type="hidden" data-force-imageload /></div>
    <div> Text1: <input id="inputText1" type="text"><span id="spanText1Position"></span></div>
    <div>Text2: <input id="inputText2" type="text"><span id="spanText2Position"></span></div>
    <div>Canvas color: <input id="inputCanvasColor" type="color" value="#000000"></div>

    <button id="btnDownload">Download</button>
    <a id="btnDeeplink" href="">DeepLink</a>
    <a id="btnReset" href="?">Reset All</a><br />
    <canvas width="1280" height="720" id="canvas"></canvas>

    <div id="poseList"></div>
    <div id="generatedPoseList"></div>
    <div id="generatedBackgroundList"></div>
</body>

<script type="text/javascript">
    const eId = function (id) { return document.getElementById(id); };

    const posesCount = 28
    const urlBackground = ''
    const urlAB = ''

    inputText1.value = 'Welt'
    inputText2.value = 'Hallo'
    inputPose.value = Math.floor(Math.random() * posesCount)

    var imgBackground = null
    var imgLogo = null
    var imgPose = null
    var imgSecond = null
    var imgThird = null
    var poseProcessedCanvas = null
    var secondProcessedCanvas = null
    var thirdProcessedCanvas = null


    //inputBackgroundURL.value = urlBackground
    inputSecondURL.value = urlAB
    inputPose.max = posesCount - 1
    const ctx = canvas.getContext("2d");
    const colorBrand = 'rgb(255, 192, 0)'
    const colorBackground = 'black'
    const colorLogo = 'black'
    const paddingBackgroundLogoPixel = 10
    const imgPoseWidth = canvas.width * 0.5

    // One-time flag to avoid re-generating Pose when generating other images
    var suspendPoseGeminiOnce = false


    const saveToURL = function () {

        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);

        document.querySelectorAll('input').forEach((input) => {
            if (input.type === 'file') {

            } else if (input.type === 'checkbox') {
                urlParams.set(input.id, input.checked)
            } else {
                urlParams.set(input.id, input.value)
            }
        })


        btnDeeplink.href = '?' + urlParams.toString()

        // window.location.search = urlParams.toString()
    }

    const loadFromURL = function () {
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);

        document.querySelectorAll('input').forEach((input) => {
            if (urlParams.get(input.id) !== null) {
                if (input.type === 'file') {

                } else if (input.type === 'checkbox') {
                    input.checked = urlParams.get(input.id) === 'true' ? true : false
                } else {
                    input.value = urlParams.get(input.id)
                }

            }

        })


    }

	const loadImage = function (src) {
		return new Promise((resolve, reject) => {
			const img = new Image();
			img.onload = () => resolve(img);
			img.onerror = reject;
			img.src = src;
		})
	}


	const loadImagesAndRender = function () {

		// Build entries with ids to maintain mapping
		var entries = [
			{ id: 'logo', url: 'img/logo.svg' },
			{ id: inputPose.id, url: (inputPoseURL.value && !suspendPoseGeminiOnce && inputPoseURL.value.indexOf('blob22:') !== 0) ? inputPoseURL.value : ('img/poses/' + inputPose.value + '.png') }
		]

		if (inputBackgroundURL.value && inputBackgroundURL.value.indexOf('blob22:') !== 0) {
			entries.push({ id: inputBackgroundURL.id, url: inputBackgroundURL.value })
		}
		if (inputSecondURL.value && inputSecondURL.value.indexOf('blob22:') !== 0) {
			entries.push({ id: inputSecondURL.id, url: inputSecondURL.value })
		}
		if (inputThirdURL.value && inputThirdURL.value.indexOf('blob22:') !== 0) {
			entries.push({ id: inputThirdURL.id, url: inputThirdURL.value })
		}

		// Map URLs
		const mapped = entries.map(e => {
			var finalUrl = e.url
			if (finalUrl.indexOf('gemini://') === 0) {
				if (e.id === inputPose.id) {
					const poseImageUrl = 'img/poses/' + inputPose.value + '.png'
					finalUrl = './image.php?url=' + encodeURIComponent(finalUrl) + '&pose=' + encodeURIComponent(poseImageUrl)
				} else {
					finalUrl = './image.php?url=' + encodeURIComponent(finalUrl)
				}
			} else if (finalUrl.indexOf('unsplash.com') > -1 && finalUrl.indexOf('proxyoff') == -1) {
				finalUrl = './image.php?url=' + encodeURIComponent(finalUrl)
			}
			return { id: e.id, src: finalUrl }
		})

		return Promise.all(mapped.map(m => loadImage(m.src))).then(images => {
			for (var i = 0; i < mapped.length; i++) {
				const id = mapped[i].id
				const im = images[i]
				if (id === 'logo') { imgLogo = im; continue }
				if (id === inputPose.id) { imgPose = im; continue }
				if (id === inputBackgroundURL.id) { imgBackground = im; continue }
				if (id === inputSecondURL.id) { imgSecond = im; continue }
				if (id === inputThirdURL.id) { imgThird = im; continue }
			}
            updatePoseMask()
            updateSecondMask()
            updateThirdMask()
			render()
		})
	}


    const drawBackground = function () {
        // background
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = (typeof inputCanvasColor !== 'undefined' && inputCanvasColor.value) ? inputCanvasColor.value : colorBackground
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore()
    }

    const drawText1 = function () {
        // text line 1
        ctx.save();
        ctx.font = "64pt Impact"
        ctx.strokeStyle = 'black'
        ctx.lineWidth = 4
        ctx.textAlign = "end"
        ctx.textBaseline = "bottom"
        ctx.fillStyle = colorBrand //<======= here
        // Color of the shadow;  RGB, RGBA, HSL, HEX, and other inputs are valid.
        ctx.shadowColor = "white"; // string
        ctx.shadowOffsetX = 0; // integer
        ctx.shadowOffsetY = 0; // integer
        ctx.shadowBlur = 50; // integer

        drawTextT(inputText1.value, inputText1.id, canvas.width - 50, canvas.height - 50)
        ctx.restore()
    }

    const drawText2 = function () {
        // text line 1
        ctx.save();
        ctx.font = "64pt Impact"
        ctx.strokeStyle = 'black'
        ctx.lineWidth = 4
        ctx.textAlign = "start"
        ctx.textBaseline = "bottom"
        ctx.fillStyle = 'white' //<======= here
        ctx.shadowColor = "white"; // string
        ctx.shadowOffsetX = 0; // integer
        ctx.shadowOffsetY = 0; // integer
        ctx.shadowBlur = 50; // integer

        drawTextT(inputText2.value, inputText2.id, 50, canvas.height - 50)

        ctx.restore()
    }


    const drawBottomBorder = function () {
        // bottom border

        ctx.save();
        ctx.fillStyle = colorBrand
        ctx.fillRect(0, canvas.height - 20, canvas.width, 20)
        ctx.restore()
    }




    const drawTextT = function (text, tid, x, y) {
        const w = ctx.measureText(text).width
        const h = ctx.measureText(text).height
        ctx.save();
        ctx.translate(x, y)
        ctx.translate(eId(`tf_${tid}_x`).value, eId(`tf_${tid}_y`).value)
        ctx.translate(w / 2, h / 2)
        ctx.rotate(eId(`tf_${tid}_r`).value * Math.PI / 180)
        ctx.scale(eId(`tf_${tid}_s`).value * 0.01, eId(`tf_${tid}_s`).value * 0.01)
        ctx.scale(eId(`tf_${tid}_h`).checked ? -1 : 1, eId(`tf_${tid}_v`).checked ? -1 : 1)
        ctx.translate(-w / 2, -h / 2)
        ctx.fillText(text, 0, 0)
        ctx.strokeText(text, 0, 0)
        ctx.restore()
    }

    const drawImageT = function (img, tid, x, y, w, h, options) {
        ctx.save();
        ctx.translate(x, y)
        ctx.translate(eId(`tf_${tid}_x`).value, eId(`tf_${tid}_y`).value)
        if (!options?.tl) ctx.translate(w / 2, h / 2)
        ctx.rotate(eId(`tf_${tid}_r`).value * Math.PI / 180)
        ctx.scale(eId(`tf_${tid}_s`).value * 0.01, eId(`tf_${tid}_s`).value * 0.01)
        ctx.scale(eId(`tf_${tid}_h`).checked ? -1 : 1, eId(`tf_${tid}_v`).checked ? -1 : 1)
        if (!options?.tl) ctx.translate(-w / 2, -h / 2)
        ctx.drawImage(img, 0, 0, w, h);
        ctx.restore()
    }



    const drawImageLogo = function () {
        ctx.save();
        ctx.fillStyle = colorLogo
        ctx.fillRect(canvas.width - imgLogo.width - paddingBackgroundLogoPixel * 2, 0, imgLogo.width + paddingBackgroundLogoPixel * 2, imgLogo.height + paddingBackgroundLogoPixel * 2)
        ctx.drawImage(imgLogo, canvas.width - imgLogo.width - paddingBackgroundLogoPixel, paddingBackgroundLogoPixel);
        ctx.restore()
    }

    const drawImagePose = function () {
        const source = (typeof chkPoseMask !== 'undefined' && chkPoseMask.checked && poseProcessedCanvas) ? poseProcessedCanvas : imgPose
        const w = imgPoseWidth
        const h = w * source.height / source.width
        drawImageT(source, inputPose.id, canvas.width * 0.1, canvas.height * 0.3, w, h)
    }

    const drawImageBackground = function () {
        const w = Math.min(canvas.width, imgBackground.width)
        drawImageT(imgBackground, inputBackgroundURL.id, 0, 0, w, w * imgBackground.height / imgBackground.width);
    }

    const drawImageSecond = function () {
        const source = (typeof chkSecondMask !== 'undefined' && chkSecondMask.checked && secondProcessedCanvas) ? secondProcessedCanvas : imgSecond
        drawImageT(source, inputSecondURL.id, 0, 0, imgSecond.width, imgSecond.height, { tl: true });
    }


    const drawImageThird = function () {
        const source = (typeof chkThirdMask !== 'undefined' && chkThirdMask.checked && thirdProcessedCanvas) ? thirdProcessedCanvas : imgThird
        drawImageT(source, inputThirdURL.id, 0, 0, imgThird.width, imgThird.height, { tl: false });
    }


    const render = function () {
        drawBackground()
        if (imgBackground) { drawImageBackground() }
        if (imgThird) { drawImageThird() }
        if (imgPose) { drawImagePose() }
        if (imgSecond) { drawImageSecond() }
        drawImageLogo()
        drawText1()
        drawText2()
        drawBottomBorder()
        saveToURL()
    }


    // 

    function diff(x, y) {

        if (Math.sign(x) === Math.sign(y)) {

            return Math.abs(x - y);

        } else {

            return Math.abs(x) + Math.abs(y);

        };

    };

    function randn_bm() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random(); //Converting [0,1) to (0,1)
        while (v === 0) v = Math.random();
        let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        num = num / 10.0 + 0.5; // Translate to 0 -> 1
        if (num > 1 || num < 0) return randn_bm() // resample between 0 and 1
        return num
    }

    const randomizeInputByMinMax = function (el, onlyInteger) {
        const max = el.getAttribute('data-random-max') || el.max
        const min = el.getAttribute('data-random-min') || el.min
        const result = parseFloat(el.min) + randn_bm() * diff(max, min)
        if (onlyInteger) {
            el.value = parseInt(result)
        } else {
            el.value = result
        }

    }
    const randomizeTransform = function (id) {
        randomizeInputByMinMax(eId('tf_' + id + '_x'))
        randomizeInputByMinMax(eId('tf_' + id + '_y'))
        randomizeInputByMinMax(eId('tf_' + id + '_r'))
        randomizeInputByMinMax(eId('tf_' + id + '_s'))
        eId('tf_' + id + '_h').checked = randn_bm() > 0.5 ? 1 : 0
        eId('tf_' + id + '_v').checked = randn_bm() > 0.5 ? 1 : 0
        render()
    }

    const resetInput = el => el.value = el.defaultValue
    const resetTransform = function (id) {
        resetInput(eId('tf_' + id + '_x'))
        resetInput(eId('tf_' + id + '_y'))
        resetInput(eId('tf_' + id + '_r'))
        resetInput(eId('tf_' + id + '_s'))
        eId('tf_' + id + '_h').checked = 0
        eId('tf_' + id + '_v').checked = 0
        render()
    }

    const addTransformMenu = function (id, menuElement) {
        menuElement.innerHTML = `x/y/s/r/m: <input id="tf_${id}_x" type="range" min="-960" max="1280" value="0" title="x"/><input id="tf_${id}_y" type="range" min="-1280" max="640" value="0" title="y"/><input id="tf_${id}_s" type="range" min="0" max="1000" value="100" data-random-min="50" data-random-max="250" title="scale"/><input id="tf_${id}_r" type="range" min="-360" max="360" value="0" title="rotation"/><input title="mirror horizontal" type="checkbox" id="tf_${id}_h"/><input title="mirror vertical" type="checkbox" id="tf_${id}_v"/><button title="chaos" onclick="randomizeTransform('${id}')">c</button><button title="reset" onclick="resetTransform('${id}')">r</button>`
    }

    addTransformMenu(inputPose.id, spanPosesPosition)
    addTransformMenu(inputBackgroundURL.id, spanBackgroundPosition)
    addTransformMenu(inputText1.id, spanText1Position)
    addTransformMenu(inputText2.id, spanText2Position)
    addTransformMenu(inputSecondURL.id, spanSecondPosition)
    addTransformMenu(inputThirdURL.id, spanThirdPosition)

    const escapeHtml = function (s) {
        return String(s || '').replace(/[&<>"']/g, function (c) {
            return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[c];
        })
    }

    const populateAssetLists = function () {
        fetch('./assets.php')
            .then(r => r.json())
            .then(data => {
                if (Array.isArray(data.normalPoses)) {
                    poseList.innerHTML = data.normalPoses.map(p => "<img onclick=\"inputPose.value=" + p.index + ";inputPoseURL.value='';inputPoseKeyColor.dataset.sampled='';loadImagesAndRender()\" src=\"" + p.thumb + "\">").join("")
                    inputPose.max = Math.max(0, data.normalPoses.length - 1)
                    if (parseInt(inputPose.value, 10) > parseInt(inputPose.max, 10)) {
                        inputPose.value = inputPose.max
                    }
                }
                if (Array.isArray(data.generatedPoses)) {
                    generatedPoseList.innerHTML = data.generatedPoses.map(g => "<span class=\"assetItem\"><img title=\"" + escapeHtml(g.prompt) + "\" onclick=\"inputPoseURL.value='" + g.url + "';inputPoseKeyColor.dataset.sampled='';loadImagesAndRender()\" src=\"" + g.thumb + "\"><button class=\"deleteBtn\" title=\"Delete pose\" onclick=\"deleteGeneratedAsset('pose','" + g.url + "')\">×</button></span>").join("")
                }
                if (Array.isArray(data.generatedBackgrounds)) {
                    generatedBackgroundList.innerHTML = data.generatedBackgrounds.map(g => "<span class=\"assetItem\"><img title=\"" + escapeHtml(g.prompt) + "\" onclick=\"inputBackgroundURL.value='" + g.url + "';loadImagesAndRender()\" src=\"" + g.thumb + "\"><button class=\"deleteBtn\" title=\"Delete background\" onclick=\"deleteGeneratedAsset('background','" + g.url + "')\">×</button></span>").join("")
                }
            })
            .catch(() => { /* ignore */ })
    }



    // Toggle visibility of prompt inputs for Background and SecondImage
    btnPromptBackground.addEventListener('click', function () {
        spanPromptBackground.style.display = (spanPromptBackground.style.display === 'none' || !spanPromptBackground.style.display) ? 'inline' : 'none'
    })
    btnPromptSecond.addEventListener('click', function () {
        spanPromptSecond.style.display = (spanPromptSecond.style.display === 'none' || !spanPromptSecond.style.display) ? 'inline' : 'none'
    })
    btnPromptThird.addEventListener('click', function () {
        spanPromptThird.style.display = (spanPromptThird.style.display === 'none' || !spanPromptThird.style.display) ? 'inline' : 'none'
    })
	// Toggle visibility for Pose prompt
	btnPromptPose.addEventListener('click', function () {
		spanPromptPose.style.display = (spanPromptPose.style.display === 'none' || !spanPromptPose.style.display) ? 'inline' : 'none'
	})

    // Enter in prompt fields triggers associated Generate button
    inputPromptBackground.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') { e.preventDefault(); btnGenerateBackground.click(); }
    })
    inputPromptSecond.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') { e.preventDefault(); btnGenerateSecond.click(); }
    })
    inputPromptThird.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') { e.preventDefault(); btnGenerateThird.click(); }
    })
	// Enter in Pose prompt triggers Generate
	inputPromptPose.addEventListener('keydown', function (e) {
		if (e.key === 'Enter') { e.preventDefault(); btnGeneratePose.click(); }
	})

    // Generate via Gemini for Background (with optional reference images)
    btnGenerateBackground.addEventListener('click', function () {
        const prompt = inputPromptBackground.value.trim()
        if (!prompt) { return }
        const previousText = this.textContent
        this.disabled = true
        this.textContent = '⏳'

        // Build image.php request with refs: Background (if checkbox), then Pose, Second, Third
        const wasBg = inputBackgroundURL.value
        const isBlob = s => (String(s || '').indexOf('blob:') === 0 || String(s || '').indexOf('blob22:') === 0)
        const toProxyUrl = s => {
            if (!s) return ''
            if (s.indexOf('./image.php') === 0 || s.indexOf('image.php') === 0) return s
            if (s.indexOf('http://') === 0 || s.indexOf('https://') === 0) return './image.php?url=' + encodeURIComponent(s)
            if (s.indexOf('gemini://') === 0) return './image.php?url=' + encodeURIComponent(s)
            // local file path (e.g., img/poses/..)
            return s
        }

        let finalUrl = './image.php?url=' + encodeURIComponent('gemini://' + prompt)

        // Background ref (only when checkbox is checked); still proceed if not present
        if (typeof chkBgBackground !== 'undefined' && chkBgBackground.checked) {
            if (wasBg && !isBlob(wasBg)) {
                const bgRef = toProxyUrl(wasBg)
                if (bgRef) { finalUrl += '&ref_background=' + encodeURIComponent(bgRef) }
            }
        }

        // Pose ref (optional)
        if (typeof chkBgPose !== 'undefined' && chkBgPose.checked) {
            let poseRef = ''
            if (inputPoseURL.value && String(inputPoseURL.value).indexOf('blob:') !== 0) {
                poseRef = toProxyUrl(inputPoseURL.value)
            } else {
                poseRef = 'img/poses/' + inputPose.value + '.png'
            }
            if (poseRef) { finalUrl += '&ref_pose=' + encodeURIComponent(poseRef) }
        }

        // Second ref (optional)
        if (typeof chkBgSecond !== 'undefined' && chkBgSecond.checked) {
            const s = inputSecondURL.value
            if (s && !isBlob(s)) {
                const secRef = toProxyUrl(s)
                if (secRef) { finalUrl += '&ref_second=' + encodeURIComponent(secRef) }
            }
        }

        // Third ref (optional)
        if (typeof chkBgThird !== 'undefined' && chkBgThird.checked) {
            const t = inputThirdURL.value
            if (t && !isBlob(t)) {
                const thRef = toProxyUrl(t)
                if (thRef) { finalUrl += '&ref_third=' + encodeURIComponent(thRef) }
            }
        }

        // Set and render
        inputBackgroundURL.value = finalUrl
        suspendPoseGeminiOnce = true
        loadImagesAndRender()
            .then(() => {
                suspendPoseGeminiOnce = false
                this.disabled = false
                this.textContent = previousText
            })
            .catch(() => {
                suspendPoseGeminiOnce = false
                this.disabled = false
                this.textContent = previousText
            })
    })

    // Generate via Gemini for SecondImage
	btnGenerateSecond.addEventListener('click', function () {
		const prompt = inputPromptSecond.value.trim()
		if (!prompt) { return }
		const previousText = this.textContent
		this.disabled = true
		this.textContent = '⏳'
        inputSecondURL.value = 'gemini://' + prompt
		suspendPoseGeminiOnce = true
		loadImagesAndRender()
			.then(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
			.catch(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
	})

    // Generate via Gemini for ThirdImage
	btnGenerateThird.addEventListener('click', function () {
		const prompt = inputPromptThird.value.trim()
		if (!prompt) { return }
		const previousText = this.textContent
		this.disabled = true
		this.textContent = '⏳'
        inputThirdURL.value = 'gemini://' + prompt
		suspendPoseGeminiOnce = true
		loadImagesAndRender()
			.then(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
			.catch(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
	})

    // --- Pose masking utilities ---
    const hexToRgb = function (hex) {
        try {
            const h = hex.replace('#','')
            const n = parseInt(h, 16)
            if (h.length === 6) {
                return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 }
            }
        } catch(e) { }
        return { r: 255, g: 0, b: 255 }
    }

    const samplePoseKeyFromBorders = function (img, sample) {
        const w = img.width, h = img.height
        const s = Math.max(1, Math.min(sample, Math.min(w, h)))
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const c = off.getContext('2d')
        c.drawImage(img, 0, 0)
        const get = (x,y)=>c.getImageData(x,y,1,1).data
        let sumR=0,sumG=0,sumB=0,cnt=0
        for (let x=0;x<w;x++) {
            for (let y=0;y<s;y++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
            for (let y=h-s;y<h;y++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
        }
        for (let y=0;y<h;y++) {
            for (let x=0;x<s;x++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
            for (let x=w-s;x<w;x++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
        }
        return { r: Math.round(sumR/cnt), g: Math.round(sumG/cnt), b: Math.round(sumB/cnt) }
    }

    const updatePoseMask = function () {
        poseProcessedCanvas = null
        if (!imgPose) return
        if (typeof chkPoseMask === 'undefined' || !chkPoseMask.checked) return
        const tol = parseInt(inputPoseTolerance.value || '0', 10)
        const soft = parseInt(inputPoseSoftness.value || '0', 10)
        let rgb = hexToRgb(inputPoseKeyColor.value || '#ff66cc')
        // If color is default and we have an image, auto-sample on first run
        if (!inputPoseKeyColor.dataset.sampled) {
            const sampled = samplePoseKeyFromBorders(imgPose, 5)
            rgb = sampled
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputPoseKeyColor.value = hex
            inputPoseKeyColor.dataset.sampled = '1'
        }

        const w = imgPose.width, h = imgPose.height
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const ctx2 = off.getContext('2d')
        ctx2.drawImage(imgPose, 0, 0)
        const imgData = ctx2.getImageData(0, 0, w, h)
        const data = imgData.data
        const thr = Math.max(0, tol)
        const sf = Math.max(0, soft)
        const softLo = Math.max(0, thr - sf)
        const softHi = thr + sf
        for (let i=0;i<data.length;i+=4){
            const r=data[i], g=data[i+1], b=data[i+2]
            const dr=r-rgb.r, dg=g-rgb.g, db=b-rgb.b
            const d=Math.sqrt(dr*dr+dg*dg+db*db)
            let alphaFactor = 1
            if (d <= softLo) {
                alphaFactor = 0
            } else if (d < softHi) {
                alphaFactor = (d - softLo) / (softHi - softLo)
            }
            data[i+3] = Math.round(data[i+3] * alphaFactor)
        }
        ctx2.putImageData(imgData, 0, 0)
        poseProcessedCanvas = off
    }

    const updateSecondMask = function () {
        secondProcessedCanvas = null
        if (!imgSecond) return
        if (typeof chkSecondMask === 'undefined' || !chkSecondMask.checked) return
        const tol = parseInt(inputSecondTolerance.value || '0', 10)
        const soft = parseInt(inputSecondSoftness.value || '0', 10)
        let rgb = hexToRgb(inputSecondKeyColor.value || '#ff66cc')
        if (!inputSecondKeyColor.dataset.sampled) {
            const sampled = samplePoseKeyFromBorders(imgSecond, 5)
            rgb = sampled
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputSecondKeyColor.value = hex
            inputSecondKeyColor.dataset.sampled = '1'
        }
        const w = imgSecond.width, h = imgSecond.height
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const ctx2 = off.getContext('2d')
        ctx2.drawImage(imgSecond, 0, 0)
        const imgData = ctx2.getImageData(0, 0, w, h)
        const data = imgData.data
        const thr = Math.max(0, tol)
        const sf = Math.max(0, soft)
        const softLo = Math.max(0, thr - sf)
        const softHi = thr + sf
        for (let i=0;i<data.length;i+=4){
            const r=data[i], g=data[i+1], b=data[i+2]
            const dr=r-rgb.r, dg=g-rgb.g, db=b-rgb.b
            const d=Math.sqrt(dr*dr+dg*dg+db*db)
            let alphaFactor = 1
            if (d <= softLo) {
                alphaFactor = 0
            } else if (d < softHi) {
                alphaFactor = (d - softLo) / (softHi - softLo)
            }
            data[i+3] = Math.round(data[i+3] * alphaFactor)
        }
        ctx2.putImageData(imgData, 0, 0)
        secondProcessedCanvas = off
    }

    const updateThirdMask = function () {
        thirdProcessedCanvas = null
        if (!imgThird) return
        if (typeof chkThirdMask === 'undefined' || !chkThirdMask.checked) return
        const tol = parseInt(inputThirdTolerance.value || '0', 10)
        const soft = parseInt(inputThirdSoftness.value || '0', 10)
        let rgb = hexToRgb(inputThirdKeyColor.value || '#ff66cc')
        if (!inputThirdKeyColor.dataset.sampled) {
            const sampled = samplePoseKeyFromBorders(imgThird, 5)
            rgb = sampled
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputThirdKeyColor.value = hex
            inputThirdKeyColor.dataset.sampled = '1'
        }
        const w = imgThird.width, h = imgThird.height
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const ctx2 = off.getContext('2d')
        ctx2.drawImage(imgThird, 0, 0)
        const imgData = ctx2.getImageData(0, 0, w, h)
        const data = imgData.data
        const thr = Math.max(0, tol)
        const sf = Math.max(0, soft)
        const softLo = Math.max(0, thr - sf)
        const softHi = thr + sf
        for (let i=0;i<data.length;i+=4){
            const r=data[i], g=data[i+1], b=data[i+2]
            const dr=r-rgb.r, dg=g-rgb.g, db=b-rgb.b
            const d=Math.sqrt(dr*dr+dg*dg+db*db)
            let alphaFactor = 1
            if (d <= softLo) {
                alphaFactor = 0
            } else if (d < softHi) {
                alphaFactor = (d - softLo) / (softHi - softLo)
            }
            data[i+3] = Math.round(data[i+3] * alphaFactor)
        }
        ctx2.putImageData(imgData, 0, 0)
        thirdProcessedCanvas = off
    }

    // UI events for pose masking
    if (typeof chkPoseMask !== 'undefined') {
        chkPoseMask.addEventListener('change', function(){ updatePoseMask(); render(); })
    }
    if (typeof inputPoseKeyColor !== 'undefined') {
        inputPoseKeyColor.addEventListener('input', function(){ inputPoseKeyColor.dataset.sampled='1'; updatePoseMask(); render(); })
    }
    if (typeof inputPoseTolerance !== 'undefined') {
        inputPoseTolerance.addEventListener('input', function(){ updatePoseMask(); render(); })
    }
    if (typeof inputPoseSoftness !== 'undefined') {
        inputPoseSoftness.addEventListener('input', function(){ updatePoseMask(); render(); })
    }
    if (typeof btnPoseSample !== 'undefined') {
        btnPoseSample.addEventListener('click', function(){
            if (!imgPose) return
            const sampled = samplePoseKeyFromBorders(imgPose, 5)
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputPoseKeyColor.value = hex
            inputPoseKeyColor.dataset.sampled = '1'
            updatePoseMask(); render();
        })
    }

    // UI events for second image masking
    if (typeof chkSecondMask !== 'undefined') {
        chkSecondMask.addEventListener('change', function(){ updateSecondMask(); render(); })
    }
    if (typeof inputSecondKeyColor !== 'undefined') {
        inputSecondKeyColor.addEventListener('input', function(){ inputSecondKeyColor.dataset.sampled='1'; updateSecondMask(); render(); })
    }
    if (typeof inputSecondTolerance !== 'undefined') {
        inputSecondTolerance.addEventListener('input', function(){ updateSecondMask(); render(); })
    }
    if (typeof inputSecondSoftness !== 'undefined') {
        inputSecondSoftness.addEventListener('input', function(){ updateSecondMask(); render(); })
    }
    if (typeof btnSecondSample !== 'undefined') {
        btnSecondSample.addEventListener('click', function(){
            if (!imgSecond) return
            const sampled = samplePoseKeyFromBorders(imgSecond, 5)
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputSecondKeyColor.value = hex
            inputSecondKeyColor.dataset.sampled = '1'
            updateSecondMask(); render();
        })
    }

    // UI events for third image masking
    if (typeof chkThirdMask !== 'undefined') {
        chkThirdMask.addEventListener('change', function(){ updateThirdMask(); render(); })
    }
    if (typeof inputThirdKeyColor !== 'undefined') {
        inputThirdKeyColor.addEventListener('input', function(){ inputThirdKeyColor.dataset.sampled='1'; updateThirdMask(); render(); })
    }
    if (typeof inputThirdTolerance !== 'undefined') {
        inputThirdTolerance.addEventListener('input', function(){ updateThirdMask(); render(); })
    }
    if (typeof inputThirdSoftness !== 'undefined') {
        inputThirdSoftness.addEventListener('input', function(){ updateThirdMask(); render(); })
    }
    if (typeof btnThirdSample !== 'undefined') {
        btnThirdSample.addEventListener('click', function(){
            if (!imgThird) return
            const sampled = samplePoseKeyFromBorders(imgThird, 5)
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputThirdKeyColor.value = hex
            inputThirdKeyColor.dataset.sampled = '1'
            updateThirdMask(); render();
        })
    }

	// Generate via Gemini for Pose (passes pose index to backend)
	btnGeneratePose.addEventListener('click', function () {
		const prompt = inputPromptPose.value.trim()
		if (!prompt) { return }
		const previousText = this.textContent
		this.disabled = true
		this.textContent = '⏳'
		inputPoseURL.value = 'gemini://' + prompt
		loadImagesAndRender()
			.then(() => {
				this.disabled = false
				this.textContent = previousText
			})
			.catch(() => {
				this.disabled = false
				this.textContent = previousText
			})
	})

	// Clicking the pose input should revert to normal pose selection
	if (typeof inputPose !== 'undefined') {
		inputPose.addEventListener('click', function(){
			if (inputPoseURL.value) {
				inputPoseURL.value = ''
				if (typeof inputPoseKeyColor !== 'undefined') { inputPoseKeyColor.dataset.sampled = '' }
				loadImagesAndRender()
			}
		})
	}


    document.querySelectorAll('[data-image-target]').forEach((input) => input.onchange = function (e) {
        const inp = eId(e.target.getAttribute('data-image-target'))
        inp.value = URL.createObjectURL(this.files[0]);
        loadImagesAndRender()
    })

    loadFromURL()
    loadImagesAndRender()
    populateAssetLists()

    tf_inputSecondURL_s.value = 27



    document.querySelectorAll('input').forEach((input) => input.addEventListener('input', render))
    document.querySelectorAll('input').forEach((input) => input.addEventListener('change', render))
    document.querySelectorAll('input').forEach((input) => input.addEventListener('keyup', render))
    document.querySelectorAll('[data-force-imageload]').forEach((input) => input.addEventListener('change', loadImagesAndRender))
    document.querySelectorAll('[data-force-imageload]').forEach((input) => input.addEventListener('keyup', loadImagesAndRender))

    // download it

    btnDownload.addEventListener('click', function (e) {
        let canvasUrl = canvas.toDataURL('image/jpeg', 1.0);
        const createEl = document.createElement('a');
        createEl.href = canvasUrl;
        createEl.download = "download-this-canvas";
        createEl.click();
        createEl.remove();
    })

    // Deletion of generated assets (one-by-one)
    function deleteGeneratedAsset(type, url) {
        try {
            const parts = String(url || '').split('/');
            const fname = parts[parts.length - 1];
            if (!fname) { return; }
            if (!confirm('Delete this ' + type + '?')) { return; }
            const body = 'action=delete&type=' + encodeURIComponent(type) + '&file=' + encodeURIComponent(fname)
            fetch('./assets.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body
            })
                .then(r => r.json())
                .then(res => {
                    if (res && res.success) {
                        // Clear current selection if it was the deleted one
                        if (type === 'pose' && (inputPoseURL.value || '').endsWith('/' + fname)) {
                            inputPoseURL.value = '';
                            inputPoseKeyColor.dataset.sampled = '';
                            loadImagesAndRender();
                        }
                        if (type === 'background' && (inputBackgroundURL.value || '').endsWith('/' + fname)) {
                            inputBackgroundURL.value = '';
                            loadImagesAndRender();
                        }
                        populateAssetLists();
                    } else {
                        alert('Delete failed');
                    }
                })
                .catch(() => alert('Delete failed'))
        } catch (e) { /* ignore */ }
    }

</script>

</html>