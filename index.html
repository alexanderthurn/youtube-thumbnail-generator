<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Free Youtube Thumbnail Generator</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <style>
        img {
            border: 1px solid black;
        }

        canvas {
            background-color: black;
        }

        .highlight {
            background-color: green;
        }

        .assetItem { position: relative; display: inline-block; margin: 2px; vertical-align: top; }
        .assetItem img { display: block; }
        .deleteBtn { position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.6); color: #fff; border: none; border-radius: 0px; cursor: pointer; font-size: 12px; line-height: 1; padding: 2px 4px; }
        .assetBtn { position: absolute; top: 2px; background: rgba(0,0,0,0.6); color: #fff; border: none; border-radius: 0px; cursor: pointer; font-size: 12px; line-height: 1; padding: 2px 4px; }
        .assetBtn--send { right: 24px; }
        .selectedControl { background: transparent; outline: 3px solid var(--accent); outline-offset: 2px; }
        .selectedSection { background: var(--accent); color: #000; outline: 0; }
        .canvasFocused { outline: 3px solid var(--accent); }
    </style>
</head>

<body>
    <header class="topbar">
        <div class="topbar__left">
            <img class="topbar__logo" src="img/favicon_small.png" alt="Werteherren" />
            <span class="topbar__title">Free Youtube Thumbnail Generator</span>
        </div>
        <div class="topbar__right">
            <a class="btn btn--primary" href="https://github.com/alexanderthurn/free-youtube-thumbnail-generator" target="_blank" rel="noopener">Github</a>
        </div>
    </header>
    <main class="layout">
    <aside class="sidebar">
    <section class="panel glass" id="card-background">
        <div class="ui-level-0"><a href="https://unsplash.com/s/photos/werte?license=free" target="unsplash">Background</a>: <input
                id="inputBackgroundURL" type="text" size="10" data-force-imageload><input type="file"
                data-image-target="inputBackgroundURL" /><span id="spanBackgroundPosition" class="ui-level-1"></span><button id="btnPromptBackground" class="ui-level-0" title="Generate with prompt">AI</button><span id="spanPromptBackground" class="ui-level-0" style="display:none;">
                <div class="prompt-label">Gemini AI</div>
                <textarea id="inputPromptBackground" rows="5" class="prompt-textarea" placeholder="Describe background..."></textarea>
                <button id="btnGenerateBackground" title="Generate background image">Generate</button>
                <label class="ui-level-1" title="Include Background as reference"><input id="chkBgBackground" type="checkbox"> Background</label> <label class="ui-level-1" title="Include Pose as reference"><input id="chkBgPose" type="checkbox"> Pose</label> <label class="ui-level-1" title="Include SecondImage as reference"><input id="chkBgSecond" type="checkbox"> SecondImage</label> <label class="ui-level-1" title="Include ThirdImage as reference"><input id="chkBgThird" type="checkbox"> ThirdImage</label>
                </span></div>
    </section>

    <section class="panel glass" id="card-pose">
        <div class="ui-level-0">Pose: <input id="inputPose" step="1" type="number" min="0" max="30" data-force-imageload /><button
                class="icon-btn" title="Randomize pose" aria-label="Randomize pose" onclick="inputPoseURL.value=''; if (typeof inputPoseKeyColor!=='undefined'){ inputPoseKeyColor.dataset.sampled=''; } randomizeInputByMinMax(inputPose, true); loadImagesAndRender()">üé≤</button><span
                id="spanPoses"></span><span id="spanPosesPosition" class="ui-level-1"></span><button id="btnPromptPose" class="ui-level-0" title="Generate with prompt">AI</button><span id="spanPromptPose" class="ui-level-1" style="display:none;">
                <div class="prompt-label">Gemini AI</div>
                <textarea id="inputPromptPose" rows="5" class="prompt-textarea" placeholder="Describe pose edit...">Using the provided image of a man in a suit, give him a magic hat. Ensure the man's face and features remain completely unchanged. The background has to be #ff00ff.</textarea>
                <button id="btnGeneratePose" title="Generate pose image">Generate</button> <label title="Apply chroma key to pose"><input id="chkPoseMask" type="checkbox" checked> Mask</label> <button id="btnPoseSample" title="Sample key color from borders of pose">Sample</button> Color: <input id="inputPoseKeyColor" type="color" value="#ff00ff"> Tolerance: <input id="inputPoseTolerance" type="range" min="-1" max="255" value="0"> <br>Softness: <input id="inputPoseSoftness" type="range" min="-1" max="255" value="0"></span><input id="inputPoseURL" type="hidden" data-force-imageload /></div>
    </section>

    <section class="panel glass" id="card-text1">
        <div class="ui-level-0"> Text1: <input id="inputText1" type="text"><span id="spanText1Position" class="ui-level-1"></span></div>
    </section>

    <section class="panel glass" id="card-text2">
        <div class="ui-level-0">Text2: <input id="inputText2" type="text"><span id="spanText2Position" class="ui-level-1"></span></div>
    </section>

    <section class="panel glass ui-level-1" id="card-second">
        <div class="ui-level-1"><a href="https://library.techsmith.com/en/camtasia/assets/Graphic/Photo">Image1</a>: <input
                id="inputSecondURL" type="text" size="10" data-force-imageload><input type="file"
                data-image-target="inputSecondURL" /><span id="spanSecondPosition"></span><button id="btnPromptSecond" title="Generate with prompt">AI</button><span id="spanPromptSecond" style="display:none;">
                <div class="prompt-label">Gemini AI</div>
                <textarea id="inputPromptSecond" rows="4" class="prompt-textarea" placeholder="Describe second image...">A cute panda. The background has to be #ff00ff.</textarea>
                <button id="btnGenerateSecond" title="Generate second image">Generate</button> <label title="Apply chroma key to SecondImage"><input id="chkSecondMask" type="checkbox" checked> Mask</label> <button id="btnSecondSample" title="Sample key color from borders of SecondImage">Sample</button> Color: <input id="inputSecondKeyColor" type="color" value="#ff00ff"> Tolerance: <input id="inputSecondTolerance" type="range" min="-1" max="255" value="0"> <br>Softness: <input id="inputSecondSoftness" type="range" min="-1" max="255" value="0"></span></div>
    </section>

    <section class="panel glass ui-level-1" id="card-third">
        <div class="ui-level-1">Image2: <input id="inputThirdURL" type="text" size="10" data-force-imageload><input type="file"
                data-image-target="inputThirdURL" /><span id="spanThirdPosition"></span><button id="btnPromptThird" title="Generate with prompt">AI</button><span id="spanPromptThird" style="display:none;">
                <div class="prompt-label">Gemini AI</div>
                <textarea id="inputPromptThird" rows="4" class="prompt-textarea" placeholder="Describe third image...">A mighty eagle.The background has to be #ff00ff.</textarea>
                <button id="btnGenerateThird" title="Generate third image">Generate</button> <label title="Apply chroma key to ThirdImage"><input id="chkThirdMask" type="checkbox" checked> Mask</label> <button id="btnThirdSample" title="Sample key color from borders of ThirdImage">Sample</button> Color: <input id="inputThirdKeyColor" type="color" value="#ff00ff"> Tolerance: <input id="inputThirdTolerance" type="range" min="-1" max="255" value="0"> <br>Softness: <input id="inputThirdSoftness" type="range" min="-1" max="255" value="0"></span></div>
    </section>

    <section class="panel glass" id="card-canvascolor">
        <div class="ui-level-0">Background color: <input id="inputCanvasColor" type="color" value="#000000"> <span class="color-swatches">
            <button class="swatch" title="Brand" style="--c:#ffc000; background: var(--c);" onclick="inputCanvasColor.value='#ffc000'; render()" aria-label="Brand color"></button>
            <button class="swatch" title="Pink" style="--c:#ff00ff; background: var(--c);" onclick="inputCanvasColor.value='#ff00ff'; render()" aria-label="Pink"></button>
            <button class="swatch" title="Cyan" style="--c:#00ffff; background: var(--c);" onclick="inputCanvasColor.value='#00ffff'; render()" aria-label="Cyan"></button>
            <button class="swatch" title="Lime" style="--c:#39ff14; background: var(--c);" onclick="inputCanvasColor.value='#39ff14'; render()" aria-label="Lime"></button>
            <button class="swatch" title="Red" style="--c:#ff0000; background: var(--c);" onclick="inputCanvasColor.value='#ff0000'; render()" aria-label="Red"></button>
            <button class="swatch" title="Violet" style="--c:#7f00ff; background: var(--c);" onclick="inputCanvasColor.value='#7f00ff'; render()" aria-label="Violet"></button>
            <button class="swatch" title="Black" style="--c:#000000; background: var(--c);" onclick="inputCanvasColor.value='#000000'; render()" aria-label="Black"></button>
            <button class="swatch" title="White" style="--c:#ffffff; background: var(--c);" onclick="inputCanvasColor.value='#ffffff'; render()" aria-label="White"></button>
        </span></div>
    </section>

    <section class="panel glass" id="card-mode">
        <div class="ui-level-0">Mode:
            <select id="selectUiLevel">
                <option value="0">Simple</option>
                <option value="1">Advanced</option>
                <option value="2">Expert</option>
            </select>
            <label class="ui-level-2"><input type="checkbox" id="toggleReducedMotion"> Reduced motion</label>
            <div style="margin-top:6px;">
                <label for="inputGeminiKey" title="Used if no .env key is present">Gemini key:</label>
                <input id="inputGeminiKey" name="no-autofill-gemini" type="password" placeholder="Enter Gemini API key" autocomplete="new-password" autocapitalize="none" autocorrect="off" spellcheck="false" data-lpignore="true" data-1p-ignore="true" style="width: 100%; max-width: 320px;" readonly>
                <div style="margin-top:4px; font-size: 12px; opacity: 0.9;">
                    No key yet? <a href="https://aistudio.google.com/api-keys" target="_blank" rel="noopener">Create one at Google AI Studio</a>
                </div>
            </div>
        </div>
    </section>

    
    </aside>
    <section id="canvas-wrap" class="canvas-wrap">
        <canvas width="1280" height="720" id="canvas"></canvas>
        <div class="actions-bar" id="card-actions">
            <div class="actions__row">
                <button id="btnDownload" class="ui-level-0 btn btn--primary">Download</button>
                <a id="btnDeeplink" class="ui-level-0" href="">DeepLink</a>
                <a id="btnReset" class="ui-level-0" href="?">Reset All</a>
            </div>
        </div>
    </section>

    <div id="listsTabs" class="ui-level-1" style="margin: 8px 0 4px 0;">
        <div class="thumbs-header">
            <div style="display:inline-block; margin-left: 0;">
                <button id="tabPoses" class="btn">Poses</button>
                <button id="tabAiPoses" class="btn">AI Poses</button>
                <button id="tabAiBackgrounds" class="btn">AI Backgrounds</button>
                <button id="tabAiObjects" class="btn">AI Objects</button>
                <button id="tabHistory" class="btn">History</button>
            </div>
        </div>
    </div>

    <div id="poseList" class="ui-level-1">
        <div id="poseListItems"></div>
    </div>
    <div id="generatedPoseList" class="ui-level-1" style="display:none;">
        <div id="generatedPoseListItems"></div>
    </div>
    <div id="generatedBackgroundList" class="ui-level-1" style="display:none;">
        <div id="generatedBackgroundListItems"></div>
    </div>
    <div id="generatedObjectList" class="ui-level-1" style="display:none;">
        <div id="generatedObjectListItems"></div>
    </div>
    <div id="resultsList" class="ui-level-1" style="display:none;">
        <div id="resultsListItems"></div>
    </div>
    </main>

    <footer class="footer">
        <div class="footer__left">
            <span>v1.1 by </span>&nbsp;<a href="https://alexander-thurn.de" target="_blank" rel="noopener">Alexander Thurn </a>
        </div>
        <div class="footer__right">
          </div>
    </footer>
</body>

<script type="text/javascript">
    const eId = function (id) { return document.getElementById(id); };

    const posesCount = 28
    const urlBackground = ''
    const urlAB = ''

    inputText1.value = 'Hallo'
    inputText2.value = 'Welt'
    inputPose.value = Math.floor(Math.random() * posesCount)

    var imgBackground = null
    var imgLogo = null
    var imgPose = null
    var imgSecond = null
    var imgThird = null
    var poseProcessedCanvas = null
    var secondProcessedCanvas = null
    var thirdProcessedCanvas = null

    // Thumbnail pagination sizes
    const THUMBS_PAGE_SIZE = 5
    const POSES_PAGE_SIZE = 10

    // Asset list state
    var normalPosesData = []
    var generatedPosesData = []
    var generatedBackgroundsData = []
    var generatedObjectsData = []
    var resultsData = []
    var showAllGeneratedPoses = false
    var showAllGeneratedBackgrounds = false
    var showAllGeneratedObjects = false
    var showAllResults = false


    //inputBackgroundURL.value = urlBackground
    inputSecondURL.value = urlAB
    inputPose.max = posesCount - 1
    const ctx = canvas.getContext("2d");
    const colorBrand = 'rgb(255, 192, 0)'
    const colorBackground = 'black'
    const colorLogo = 'black'
    const paddingBackgroundLogoPixel = 10
    const imgPoseWidth = canvas.width * 0.5

    // One-time flag to avoid re-generating Pose when generating other images
    var suspendPoseGeminiOnce = false
    // One-time override for pose reference when generating a new pose
    var poseRefOverride = ''


    const collectCurrentParams = function(){
        const params = new URLSearchParams()
        document.querySelectorAll('input').forEach((input) => {
            if (input.type === 'file') {
                // ignore file inputs
            } else if (input.type === 'checkbox') {
                params.set(input.id, input.checked)
            } else {
                params.set(input.id, input.value)
            }
        })
        return params
    }

    const saveToURL = function () {
        const urlParams = collectCurrentParams()
        btnDeeplink.href = '?' + urlParams.toString()
        // window.location.search = urlParams.toString()
    }

    const buildDownloadFilename = function(){
        // Short, file-safe summary using only core fields with abbreviated keys
        const shortKeyMap = {
            inputBackgroundURL: 'bg',
            inputPose: 'p',
            inputSecondURL: 's2',
            inputThirdURL: 's3',
            inputText1: 't1',
            inputText2: 't2',
            inputCanvasColor: 'cc'
        }
        const ids = Object.keys(shortKeyMap)
        const getVal = id => {
            const el = eId(id)
            return el ? String(el.value || '') : ''
        }
        const shortenVal = function(id, v){
            if (!v) return ''
            // URLs ‚Üí last segment or short prompt token
            if (/^https?:\/\//i.test(v)) {
                try {
                    const u = new URL(v.indexOf('http')===0? v : v.replace(/^.*url=/,'').replace(/%2F/gi,'/'))
                    const seg = (u.pathname.split('/').pop() || '').split('?')[0]
                    return (seg || 'url').slice(0, 20)
                } catch(e){ return 'url' }
            }
            if (/^gemini:\/\//i.test(v)) {
                return ('gm_' + v.replace(/^gemini:\/\//i,'')).replace(/\W+/g,'_').slice(0, 20)
            }
            if (id === 'inputCanvasColor') {
                return v.replace('#','')
            }
            // text/numbers
            return v.replace(/\s+/g,'_').replace(/\W+/g,'_').slice(0, 20)
        }
        const parts = []
        ids.forEach(function(id){
            const val = getVal(id)
            if (!val) return
            const sk = shortKeyMap[id]
            const sv = shortenVal(id, val)
            if (sv) parts.push(sk + '-' + sv)
        })
        let base = parts.join('__') || 'img'
        base = base.replace(/_+/g,'_').replace(/^_+|_+$/g,'')
        if (base.length > 80) base = base.slice(0,80)
        return base + '.jpg'
    }

    const loadFromURL = function () {
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);

        document.querySelectorAll('input').forEach((input) => {
            if (urlParams.get(input.id) !== null) {
                if (input.type === 'file') {

                } else if (input.type === 'checkbox') {
                    input.checked = urlParams.get(input.id) === 'true' ? true : false
                } else {
                    input.value = urlParams.get(input.id)
                }

            }

        })


    }

    // --- Gemini key handling ---
    var serverHasGeminiKey = false
    const getGeminiKey = function(){
        try { return String(localStorage.getItem('geminiApiKey') || '') } catch(e) { return '' }
    }
    const setGeminiKey = function(v){
        try { localStorage.setItem('geminiApiKey', String(v || '')) } catch(e) { /* ignore */ }
    }
    if (typeof inputGeminiKey !== 'undefined') {
        try {
            var storedKey = getGeminiKey()
            if (storedKey) {
                inputGeminiKey.value = storedKey
                try { inputGeminiKey.removeAttribute('readonly') } catch(e) { /* ignore */ }
            } else {
                // Prevent password managers from autofilling when empty
                inputGeminiKey.value = ''
                // Remove readonly on user interaction only
                const unlock = function(){ try { inputGeminiKey.removeAttribute('readonly') } catch(e) { /* ignore */ } }
                inputGeminiKey.addEventListener('focus', unlock, { once: true })
                inputGeminiKey.addEventListener('mousedown', unlock, { once: true })
                inputGeminiKey.addEventListener('touchstart', unlock, { once: true })
            }
        } catch(e) { /* ignore */ }
        inputGeminiKey.addEventListener('input', function(){ setGeminiKey(this.value) })
    }
    // Probe backend for env key presence (no user key sent)
    try {
        fetch('./image.php?url=' + encodeURIComponent('gemini://check') + '&action=has_key')
            .then(function(r){ return r.ok ? r.json() : { hasKey: false } })
            .then(function(d){ serverHasGeminiKey = !!(d && d.hasKey) })
            .catch(function(){ /* ignore */ })
    } catch(e) { /* ignore */ }
    const ensureGeminiKeyOrEnv = function(){
        if (getGeminiKey()) return true
        if (serverHasGeminiKey) return true
        alert('A Gemini API key is required. Enter it under Gemini key.\nYou can create a key at https://aistudio.google.com/api-keys')
        try { if (typeof inputGeminiKey !== 'undefined') { inputGeminiKey.focus() } } catch(e) { /* ignore */ }
        return false
    }

    const loadImage = function (src) {
        return new Promise((resolve, reject) => {
            const needsHeader = /^\.?\/?image\.php(\?|$)/i.test(String(src || ''))
            if (needsHeader) {
                const headers = {}
                const k = getGeminiKey()
                if (k) { headers['X-Gemini-API-Key'] = k }
                fetch(src, { headers })
                    .then(r => { if (!r.ok) throw new Error('fetch failed: ' + r.status); return r.blob() })
                    .then(b => {
                        const url = URL.createObjectURL(b)
                        const img = new Image()
                        img.onload = () => { try { URL.revokeObjectURL(url) } catch(e){}; resolve(img) }
                        img.onerror = reject
                        img.src = url
                    })
                    .catch(reject)
                return
            }
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
        })
    }


	const loadImagesAndRender = function () {

		// Build entries with ids to maintain mapping
		var entries = [
			{ id: 'logo', url: 'img/logo.svg' },
			{ id: inputPose.id, url: (inputPoseURL.value && !suspendPoseGeminiOnce && inputPoseURL.value.indexOf('blob22:') !== 0) ? inputPoseURL.value : ('img/poses/' + inputPose.value + '.png') }
		]

		if (inputBackgroundURL.value && inputBackgroundURL.value.indexOf('blob22:') !== 0) {
			entries.push({ id: inputBackgroundURL.id, url: inputBackgroundURL.value })
		}
		if (inputSecondURL.value && inputSecondURL.value.indexOf('blob22:') !== 0) {
			entries.push({ id: inputSecondURL.id, url: inputSecondURL.value })
		}
		if (inputThirdURL.value && inputThirdURL.value.indexOf('blob22:') !== 0) {
			entries.push({ id: inputThirdURL.id, url: inputThirdURL.value })
		}

		// Map URLs
		const mapped = entries.map(e => {
			var finalUrl = e.url
            if (finalUrl.indexOf('gemini://') === 0) {
                if (e.id === inputPose.id) {
					const poseImageUrl = poseRefOverride || ('img/poses/' + inputPose.value + '.png')
					finalUrl = './image.php?url=' + encodeURIComponent(finalUrl) + '&pose=' + encodeURIComponent(poseImageUrl) + '&ar=' + encodeURIComponent('9:16')
					poseRefOverride = ''
                } else {
                    let extra = ''
                    if (e.id === inputBackgroundURL.id) { extra = '&ar=' + encodeURIComponent('16:9') }
                    if (e.id === inputSecondURL.id || e.id === inputThirdURL.id) { extra = '&ar=' + encodeURIComponent('16:9') + '&kind=object' }
                    finalUrl = './image.php?url=' + encodeURIComponent(finalUrl) + extra
				}
			} else if (finalUrl.indexOf('unsplash.com') > -1 && finalUrl.indexOf('proxyoff') == -1) {
				finalUrl = './image.php?url=' + encodeURIComponent(finalUrl)
			}
			return { id: e.id, src: finalUrl }
		})

		return Promise.all(mapped.map(m => loadImage(m.src))).then(images => {
			for (var i = 0; i < mapped.length; i++) {
				const id = mapped[i].id
				const im = images[i]
				if (id === 'logo') { imgLogo = im; continue }
				if (id === inputPose.id) { imgPose = im; continue }
				if (id === inputBackgroundURL.id) { imgBackground = im; continue }
				if (id === inputSecondURL.id) { imgSecond = im; continue }
				if (id === inputThirdURL.id) { imgThird = im; continue }
			}
            updatePoseMask()
            updateSecondMask()
            updateThirdMask()
			render()
		})
	}


    const drawBackground = function () {
        // background
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = (typeof inputCanvasColor !== 'undefined' && inputCanvasColor.value) ? inputCanvasColor.value : colorBackground
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore()
    }

    const drawText1 = function () {
        // text line 1
        ctx.save();
        ctx.font = "64pt Impact"
        ctx.strokeStyle = 'black'
        ctx.lineWidth = 4
        ctx.textAlign = "start"
        ctx.textBaseline = "bottom"
        ctx.fillStyle = 'black' 
        ctx.shadowColor = "transparent";
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.shadowBlur = 0;

        drawTextT(inputText1.value, inputText1.id, 50, canvas.height - 50)
        ctx.restore()
    }

    const drawText2 = function () {
        // text line 1
        ctx.save();
        ctx.font = "64pt Impact"
        ctx.strokeStyle = 'black'
        ctx.lineWidth = 4
        ctx.textAlign = "end"
        ctx.textBaseline = "bottom"
        ctx.fillStyle = colorBrand //<======= swapped: Text2 uses right/brand style
        // Disable glow/shadow for solid style
        ctx.shadowColor = "transparent";
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.shadowBlur = 0;

        drawTextT(inputText2.value, inputText2.id, canvas.width - 50, canvas.height - 50)

        ctx.restore()
    }


    const drawBottomBorder = function () {
        // bottom border

        ctx.save();
        ctx.fillStyle = colorBrand
        ctx.fillRect(0, canvas.height - 20, canvas.width, 20)
        ctx.restore()
    }




    const drawTextT = function (text, tid, x, y) {
        const w = ctx.measureText(text).width
        const m = ctx.measureText(text)
        const h = (m.actualBoundingBoxAscent || 40) + (m.actualBoundingBoxDescent || 10)
        ctx.save();
        ctx.translate(x, y)
        ctx.translate(eId(`tf_${tid}_x`).value, eId(`tf_${tid}_y`).value)
        ctx.translate(w / 2, h / 2)
        ctx.rotate(eId(`tf_${tid}_r`).value * Math.PI / 180)
        ctx.scale(eId(`tf_${tid}_s`).value * 0.01, eId(`tf_${tid}_s`).value * 0.01)
        ctx.scale(eId(`tf_${tid}_h`).checked ? -1 : 1, eId(`tf_${tid}_v`).checked ? -1 : 1)
        ctx.translate(-w / 2, -h / 2)
        // Compute local offset by current align/baseline
        let offX = 0, offY = 0
        const ta = String(ctx.textAlign || '').toLowerCase()
        if (ta === 'center') offX = -w / 2
        else if (ta === 'end' || ta === 'right') offX = -w
        else offX = 0
        const tb = String(ctx.textBaseline || '').toLowerCase()
        if (tb === 'bottom' || tb === 'ideographic') offY = -h
        else if (tb === 'middle') offY = -h / 2
        else offY = 0 // top/hanging/alphabetic approximated as top
        // Draw solid background for Text1 (brand yellow) and Text2 (black)
        const bgColor = (tid === inputText1.id) ? colorBrand : (tid === inputText2.id ? 'black' : '')
        const manualFontOffsetY = 11;
        const padX = 12, padY = 12
        if (bgColor) {
            const prevFill = ctx.fillStyle
            const prevStroke = ctx.strokeStyle
            const prevLineWidth = ctx.lineWidth
            ctx.fillStyle = bgColor
            ctx.fillRect(offX-padX, offY-padY, w+padX*2, h+padY*2)
            ctx.fillStyle = prevFill
            ctx.strokeStyle = prevStroke
            ctx.lineWidth = prevLineWidth
        }
        ctx.fillText(text, 0, manualFontOffsetY)
        if (typeof selectedId !== 'undefined' && selectedId === tid) {
            ctx.save()
            ctx.strokeStyle = 'rgba(255,192,0,0.9)'
            ctx.lineWidth = 2
            ctx.setLineDash([8,4])
            ctx.strokeRect(offX-padX, offY-padY, w+padX*2, h+padY*2)
            ctx.restore()
        }
        ctx.restore()
    }

    const drawImageT = function (img, tid, x, y, w, h, options) {
        ctx.save();
        ctx.translate(x, y)
        ctx.translate(eId(`tf_${tid}_x`).value, eId(`tf_${tid}_y`).value)
        if (!options?.tl) ctx.translate(w / 2, h / 2)
        ctx.rotate(eId(`tf_${tid}_r`).value * Math.PI / 180)
        ctx.scale(eId(`tf_${tid}_s`).value * 0.01, eId(`tf_${tid}_s`).value * 0.01)
        ctx.scale(eId(`tf_${tid}_h`).checked ? -1 : 1, eId(`tf_${tid}_v`).checked ? -1 : 1)
        if (!options?.tl) ctx.translate(-w / 2, -h / 2)
        ctx.drawImage(img, 0, 0, w, h);
        if (typeof selectedId !== 'undefined' && selectedId === tid) {
            ctx.save()
            ctx.strokeStyle = 'rgba(255,192,0,0.9)'
            ctx.lineWidth = 2
            ctx.setLineDash([8,4])
            ctx.strokeRect(0, 0, w, h)
            ctx.restore()
        }
        ctx.restore()
    }



    const drawImageLogo = function () {
        ctx.save();
        ctx.fillStyle = colorLogo
        ctx.fillRect(canvas.width - imgLogo.width - paddingBackgroundLogoPixel * 2, 0, imgLogo.width + paddingBackgroundLogoPixel * 2, imgLogo.height + paddingBackgroundLogoPixel * 2)
        ctx.drawImage(imgLogo, canvas.width - imgLogo.width - paddingBackgroundLogoPixel, paddingBackgroundLogoPixel);
        ctx.restore()
    }

    const drawImagePose = function () {
        const source = (typeof chkPoseMask !== 'undefined' && chkPoseMask.checked && poseProcessedCanvas) ? poseProcessedCanvas : imgPose
        const w = imgPoseWidth
        const h = w * source.height / source.width
        drawImageT(source, inputPose.id, canvas.width * 0.1, canvas.height * 0.3, w, h)
    }

    const drawImageBackground = function () {
        const w = Math.min(canvas.width, imgBackground.width)
        drawImageT(imgBackground, inputBackgroundURL.id, 0, 0, w, w * imgBackground.height / imgBackground.width);
    }

    const drawImageSecond = function () {
        const source = (typeof chkSecondMask !== 'undefined' && chkSecondMask.checked && secondProcessedCanvas) ? secondProcessedCanvas : imgSecond
        drawImageT(source, inputSecondURL.id, 0, 0, imgSecond.width, imgSecond.height, { tl: true });
    }


    const drawImageThird = function () {
        const source = (typeof chkThirdMask !== 'undefined' && chkThirdMask.checked && thirdProcessedCanvas) ? thirdProcessedCanvas : imgThird
        drawImageT(source, inputThirdURL.id, 0, 0, imgThird.width, imgThird.height, { tl: false });
    }


    const render = function () {
        drawBackground()
        if (imgBackground) { drawImageBackground() }
        if (imgThird) { drawImageThird() }
        if (imgPose) { drawImagePose() }
        if (imgSecond) { drawImageSecond() }
        drawImageLogo()
        drawText1()
        drawText2()
        drawBottomBorder()
        saveToURL()
    }


    // 

    function diff(x, y) {

        if (Math.sign(x) === Math.sign(y)) {

            return Math.abs(x - y);

        } else {

            return Math.abs(x) + Math.abs(y);

        };

    };

    function randn_bm() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random(); //Converting [0,1) to (0,1)
        while (v === 0) v = Math.random();
        let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        num = num / 10.0 + 0.5; // Translate to 0 -> 1
        if (num > 1 || num < 0) return randn_bm() // resample between 0 and 1
        return num
    }

    const randomizeInputByMinMax = function (el, onlyInteger) {
        const max = el.getAttribute('data-random-max') || el.max
        const min = el.getAttribute('data-random-min') || el.min
        const result = parseFloat(el.min) + randn_bm() * diff(max, min)
        if (onlyInteger) {
            el.value = parseInt(result)
        } else {
            el.value = result
        }

    }
    const randomizeTransform = function (id) {
        randomizeInputByMinMax(eId('tf_' + id + '_x'))
        randomizeInputByMinMax(eId('tf_' + id + '_y'))
        randomizeInputByMinMax(eId('tf_' + id + '_r'))
        randomizeInputByMinMax(eId('tf_' + id + '_s'))
        eId('tf_' + id + '_h').checked = randn_bm() > 0.5 ? 1 : 0
        eId('tf_' + id + '_v').checked = randn_bm() > 0.5 ? 1 : 0
        if (eId('tfn_' + id + '_x')) { eId('tfn_' + id + '_x').value = eId('tf_' + id + '_x').value }
        if (eId('tfn_' + id + '_y')) { eId('tfn_' + id + '_y').value = eId('tf_' + id + '_y').value }
        if (eId('tfn_' + id + '_r')) { eId('tfn_' + id + '_r').value = eId('tf_' + id + '_r').value }
        if (eId('tfn_' + id + '_s')) { eId('tfn_' + id + '_s').value = eId('tf_' + id + '_s').value }
        render()
    }

    const resetInput = el => el.value = el.defaultValue
    const resetTransform = function (id) {
        resetInput(eId('tf_' + id + '_x'))
        resetInput(eId('tf_' + id + '_y'))
        resetInput(eId('tf_' + id + '_r'))
        resetInput(eId('tf_' + id + '_s'))
        eId('tf_' + id + '_h').checked = 0
        eId('tf_' + id + '_v').checked = 0
        if (eId('tfn_' + id + '_x')) { eId('tfn_' + id + '_x').value = eId('tf_' + id + '_x').value }
        if (eId('tfn_' + id + '_y')) { eId('tfn_' + id + '_y').value = eId('tf_' + id + '_y').value }
        if (eId('tfn_' + id + '_r')) { eId('tfn_' + id + '_r').value = eId('tf_' + id + '_r').value }
        if (eId('tfn_' + id + '_s')) { eId('tfn_' + id + '_s').value = eId('tf_' + id + '_s').value }
        render()
    }

    const addTransformMenu = function (id, menuElement) {
        menuElement.innerHTML = `<br class="ui-level-2"><span class="ui-level-2">x/y/s/r/m: </span>
<input class="ui-level-2" id="tf_${id}_x" type="range" min="-1960" max="2280" value="0" title="x" oninput="eId('tfn_${id}_x').value=this.value; render()"/>
<input class=\"ui-level-2\" id="tfn_${id}_x" type="number" min="-1960" max="2280" value="0" step="1" title="x" oninput="eId('tf_${id}_x').value=this.value; render()"/>
<input class="ui-level-2" id="tf_${id}_y" type="range" min="-2280" max="1640" value="0" title="y" oninput="eId('tfn_${id}_y').value=this.value; render()"/>
<input class=\"ui-level-2\" id="tfn_${id}_y" type="number" min="-2280" max="1640" value="0" step="1" title="y" oninput="eId('tf_${id}_y').value=this.value; render()"/>
<input class="ui-level-2" id="tf_${id}_s" type="range" min="-1000" max="1000" value="100" data-random-min="50" data-random-max="250" title="scale" oninput="eId('tfn_${id}_s').value=this.value; render()"/>
<input class=\"ui-level-2\" id="tfn_${id}_s" type="number" min="-1000" max="1000" value="100" step="1" title="scale" oninput="eId('tf_${id}_s').value=this.value; render()"/>
<input class="ui-level-2" id="tf_${id}_r" type="range" min="-360" max="360" value="0" title="rotation" oninput="eId('tfn_${id}_r').value=this.value; render()"/>
<input class=\"ui-level-2\" id="tfn_${id}_r" type="number" min="-360" max="360" value="0" step="1" title="rotation" oninput="eId('tf_${id}_r').value=this.value; render()"/>
<input class="ui-level-2" title="mirror horizontal" type="checkbox" id="tf_${id}_h"/>
<input class="ui-level-2" title="mirror vertical" type="checkbox" id="tf_${id}_v"/>
<button class="ui-level-2 icon-btn" title="Randomize transform" aria-label="Randomize transform" onclick="randomizeTransform('${id}')">üé≤</button>
<button class="ui-level-2" title="reset" onclick="resetTransform('${id}')">r</button>`
    }

    addTransformMenu(inputPose.id, spanPosesPosition)
    addTransformMenu(inputBackgroundURL.id, spanBackgroundPosition)
    addTransformMenu(inputText1.id, spanText1Position)
    addTransformMenu(inputText2.id, spanText2Position)
    addTransformMenu(inputSecondURL.id, spanSecondPosition)
    addTransformMenu(inputThirdURL.id, spanThirdPosition)

    const syncTransformNumbersFor = function(id){
        const keys = ['x','y','s','r']
        keys.forEach(function(k){
            const r = eId('tf_' + id + '_' + k)
            const n = eId('tfn_' + id + '_' + k)
            if (r && n) { n.value = r.value }
        })
    }
    const syncAllTransformNumbers = function(){
        [inputPose.id, inputBackgroundURL.id, inputText1.id, inputText2.id, inputSecondURL.id, inputThirdURL.id].forEach(function(i){ syncTransformNumbersFor(i) })
    }
    syncAllTransformNumbers()

    const escapeHtml = function (s) {
        return String(s || '').replace(/[&<>"']/g, function (c) {
            return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[c];
        })
    }

    // Visual feedback for thumbnail clicks
    const flashThumb = function(el){
        try {
            const img = (el && el.tagName === 'IMG') ? el : (el && el.querySelector && el.querySelector('img'))
            if (!img) return
            img.classList.remove('thumb--flash')
            // Force reflow to restart animation
            void img.offsetWidth
            img.classList.add('thumb--flash')
            setTimeout(function(){ try { img.classList.remove('thumb--flash') } catch(e){} }, 600)
        } catch(e) { /* ignore */ }
    }

    const renderPoseList = function(){
        if (!Array.isArray(normalPosesData)) { normalPosesData = [] }
        if (typeof poseListItems !== 'undefined') {
            poseListItems.innerHTML = normalPosesData.map(function(p){
                return "<img class=\"thumb\" onclick=\"inputPose.value=" + p.index + ";inputPoseURL.value='';if (typeof chkPoseMask!=='undefined'){ chkPoseMask.checked=true; } inputPoseTolerance.value=0; inputPoseSoftness.value=0; inputPoseKeyColor.value='#ff00ff'; inputPoseKeyColor.dataset.sampled='1'; loadImagesAndRender(); flashThumb(this)\" src=\"" + p.thumb + "\">"
            }).join("")
        }
        if (typeof inputPose !== 'undefined') {
            inputPose.max = Math.max(0, normalPosesData.length - 1)
            if (parseInt(inputPose.value, 10) > parseInt(inputPose.max, 10)) {
                inputPose.value = inputPose.max
            }
        }
    }

    const renderGeneratedPoseList = function(){
        if (!Array.isArray(generatedPosesData)) { generatedPosesData = [] }
        var list = showAllGeneratedPoses ? generatedPosesData : generatedPosesData.slice(0, POSES_PAGE_SIZE)
        if (typeof generatedPoseListItems !== 'undefined') {
            var html = list.map(function(g){
                return "<span class=\"assetItem\"><img class=\"thumb\" title=\"" + escapeHtml(g.prompt) + "\" onclick=\"inputPoseURL.value='" + g.url + "'; if (typeof chkPoseMask!=='undefined'){ chkPoseMask.checked=true; } inputPoseTolerance.value=69; inputPoseSoftness.value=69; inputPoseKeyColor.dataset.sampled=''; loadImagesAndRender(); flashThumb(this)\" src=\"" + g.thumb + "\"><button class=\"deleteBtn\" title=\"Delete pose\" onclick=\"deleteGeneratedAsset(event,'pose','" + g.url + "')\">√ó</button></span>"
            }).join("")
            if (!showAllGeneratedPoses && generatedPosesData.length > POSES_PAGE_SIZE) {
                html += "<span class=\"assetItem\"><button class=\"show-all-tile\" onclick=\"showAllGeneratedPoses=true; renderGeneratedPoseList()\">Ôºã Show all</button></span>"
            }
            generatedPoseListItems.innerHTML = html
        }
    }

    const renderGeneratedBackgroundList = function(){
        if (!Array.isArray(generatedBackgroundsData)) { generatedBackgroundsData = [] }
        var list = showAllGeneratedBackgrounds ? generatedBackgroundsData : generatedBackgroundsData.slice(0, THUMBS_PAGE_SIZE)
        if (typeof generatedBackgroundListItems !== 'undefined') {
            var html = list.map(function(g){
                return "<span class=\"assetItem\"><img class=\"thumb\" title=\"" + escapeHtml(g.prompt) + "\" onclick=\"inputBackgroundURL.value='" + g.url + "';loadImagesAndRender();flashThumb(this)\" src=\"" + g.thumb + "\"><button class=\"deleteBtn\" title=\"Delete background\" onclick=\"deleteGeneratedAsset(event,'background','" + g.url + "')\">√ó</button></span>"
            }).join("")
            if (!showAllGeneratedBackgrounds && generatedBackgroundsData.length > THUMBS_PAGE_SIZE) {
                html += "<span class=\"assetItem\"><button class=\"show-all-tile\" onclick=\"showAllGeneratedBackgrounds=true; renderGeneratedBackgroundList()\">Ôºã Show all</button></span>"
            }
            generatedBackgroundListItems.innerHTML = html
        }
    }

    const renderGeneratedObjectList = function(){
        if (!Array.isArray(generatedObjectsData)) { generatedObjectsData = [] }
        var list = showAllGeneratedObjects ? generatedObjectsData : generatedObjectsData.slice(0, THUMBS_PAGE_SIZE)
        if (typeof generatedObjectListItems !== 'undefined') {
            var html = list.map(function(g){
                var sendToThirdBtn = '<button class="assetBtn assetBtn--send" title="Send to Image2" onclick="event.stopPropagation(); inputThirdURL.value=\'' + g.url + '\'; loadImagesAndRender()">‚Üí2</button>'
                return "<span class=\"assetItem\"><img class=\"thumb\" title=\"" + escapeHtml(g.prompt) + "\" onclick=\"inputSecondURL.value='" + g.url + "';loadImagesAndRender();flashThumb(this)\" src=\"" + g.thumb + "\">" + sendToThirdBtn + "<button class=\"deleteBtn\" title=\"Delete object\" onclick=\"deleteGeneratedAsset(event,'object','" + g.url + "')\">√ó</button></span>"
            }).join("")
            if (!showAllGeneratedObjects && generatedObjectsData.length > THUMBS_PAGE_SIZE) {
                html += "<span class=\"assetItem\"><button class=\"show-all-tile\" onclick=\"showAllGeneratedObjects=true; renderGeneratedObjectList()\">Ôºã Show all</button></span>"
            }
            generatedObjectListItems.innerHTML = html
        }
    }

    const renderResultsList = function(){
        if (!Array.isArray(resultsData)) { resultsData = [] }
        var list = showAllResults ? resultsData : resultsData.slice(0, THUMBS_PAGE_SIZE)
        if (typeof resultsListItems !== 'undefined') {
            var html = list.map(function(r){
                var dl = '<a class="btn" href="' + r.url + '" download>Download</a>'
                var rs = r.json ? '<button class="btn" onclick="restoreResultSettings(\'' + r.json + '\')">Restore</button>' : ''
                return '<span class="assetItem"><a href="' + r.url + '" target="_blank"><img onclick="flashThumb(this)" src="' + r.thumb + '"></a>' + dl + ' ' + rs + '<button class="deleteBtn" title="Delete result" onclick="deleteGeneratedAsset(event,\'result\',\'' + r.url + '\')">√ó</button></span>'
            }).join("")
            if (!showAllResults && resultsData.length > THUMBS_PAGE_SIZE) {
                html += "<span class=\"assetItem\"><button class=\"show-all-tile\" onclick=\"showAllResults=true; renderResultsList()\">Ôºã Show all</button></span>"
            }
            resultsListItems.innerHTML = html
        }
    }

    const populateAssetLists = function () {
        fetch('./assets.php')
            .then(r => r.json())
            .then(data => {
                if (Array.isArray(data.normalPoses)) {
                    normalPosesData = data.normalPoses
                    renderPoseList()
                }
                if (Array.isArray(data.generatedPoses)) {
                    generatedPosesData = data.generatedPoses
                    renderGeneratedPoseList()
                }
                if (Array.isArray(data.generatedBackgrounds)) {
                    generatedBackgroundsData = data.generatedBackgrounds
                    renderGeneratedBackgroundList()
                }
                if (Array.isArray(data.generatedObjects)) {
                    generatedObjectsData = data.generatedObjects
                    renderGeneratedObjectList()
                }
                if (Array.isArray(data.results)) {
                    resultsData = data.results
                    renderResultsList()
                }
            })
            .catch(() => { /* ignore */ })
    }

    // Show-all buttons
    if (typeof btnShowAllGeneratedPoses !== 'undefined') {
        btnShowAllGeneratedPoses.addEventListener('click', function(){
            showAllGeneratedPoses = true
            renderGeneratedPoseList()
        })
    }
    if (typeof btnShowAllGeneratedBackgrounds !== 'undefined') {
        btnShowAllGeneratedBackgrounds.addEventListener('click', function(){
            showAllGeneratedBackgrounds = true
            renderGeneratedBackgroundList()
        })
    }
    if (typeof btnShowAllResults !== 'undefined') {
        btnShowAllResults.addEventListener('click', function(){
            showAllResults = true
            renderResultsList()
        })
    }
    



    // --- Tabs for lists ---
    const TAB_IDS = {
        poses: 'poseList',
        aiPoses: 'generatedPoseList',
        aiBackgrounds: 'generatedBackgroundList',
        aiObjects: 'generatedObjectList',
        history: 'resultsList'
    }
    const TAB_BUTTONS = {
        poses: 'tabPoses',
        aiPoses: 'tabAiPoses',
        aiBackgrounds: 'tabAiBackgrounds',
        aiObjects: 'tabAiObjects',
        history: 'tabHistory'
    }
    const setActiveTab = function(name){
        const keys = Object.keys(TAB_IDS)
        keys.forEach(function(k){
            const el = eId(TAB_IDS[k])
            if (el) { el.style.display = (k === name ? '' : 'none') }
            const btn = eId(TAB_BUTTONS[k])
            if (btn) { btn.classList.toggle('btn--primary', k === name) }
        })
        try { localStorage.setItem('activeListTab', name) } catch(e) { }
    }
    const initTabs = function(){
        const keys = Object.keys(TAB_BUTTONS)
        keys.forEach(function(k){
            const btn = eId(TAB_BUTTONS[k])
            if (btn) { btn.addEventListener('click', function(){ setActiveTab(k) }) }
        })
        let def = 'poses'
        try { def = localStorage.getItem('activeListTab') || 'poses' } catch(e) { def = 'poses' }
        setActiveTab(def)
    }
    initTabs()

    // Toggle visibility of prompt inputs for Background and SecondImage
    btnPromptBackground.addEventListener('click', function () {
        spanPromptBackground.style.display = (spanPromptBackground.style.display === 'none' || !spanPromptBackground.style.display) ? 'inline' : 'none'
    })
    btnPromptSecond.addEventListener('click', function () {
        spanPromptSecond.style.display = (spanPromptSecond.style.display === 'none' || !spanPromptSecond.style.display) ? 'inline' : 'none'
    })
    btnPromptThird.addEventListener('click', function () {
        spanPromptThird.style.display = (spanPromptThird.style.display === 'none' || !spanPromptThird.style.display) ? 'inline' : 'none'
    })
	// Toggle visibility for Pose prompt
	btnPromptPose.addEventListener('click', function () {
		spanPromptPose.style.display = (spanPromptPose.style.display === 'none' || !spanPromptPose.style.display) ? 'inline' : 'none'
	})

    // Enter in prompt fields triggers associated Generate button
    inputPromptBackground.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') { e.preventDefault(); btnGenerateBackground.click(); }
    })
    inputPromptSecond.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') { e.preventDefault(); btnGenerateSecond.click(); }
    })
    inputPromptThird.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') { e.preventDefault(); btnGenerateThird.click(); }
    })
	// Enter in Pose prompt triggers Generate
	inputPromptPose.addEventListener('keydown', function (e) {
		if (e.key === 'Enter') { e.preventDefault(); btnGeneratePose.click(); }
	})

    // Generate via Gemini for Background (with optional reference images)
	// Helper: ensure proxy for cross-origin URLs
	const ensureProxyUrl = function(s){
		if (!s) return ''
		if (s.indexOf('./image.php') === 0 || s.indexOf('image.php') === 0) return s
		if (s.indexOf('http://') === 0 || s.indexOf('https://') === 0) return './image.php?url=' + encodeURIComponent(s)
		if (s.indexOf('gemini://') === 0) return './image.php?url=' + encodeURIComponent(s)
		return s
	}
	// Helper: fetch URL as base64 via same-origin (proxy when needed)
    const fetchUrlAsBase64 = async function(s){
        const u = ensureProxyUrl(s)
        const needsHeader = /^\.?\/?image\.php(\?|$)/i.test(String(u || ''))
        const opts = {}
        if (needsHeader) {
            const k = getGeminiKey()
            if (k) { opts.headers = { 'X-Gemini-API-Key': k } }
        }
        const r = await fetch(u, opts)
		if (!r.ok) { throw new Error('fetch failed: ' + r.status) }
		const b = await r.blob()
		const mime = b.type || 'image/png'
		return await new Promise(function(resolve){
			const reader = new FileReader()
			reader.onloadend = function(){
				const dataUrl = String(reader.result || '')
				const base64 = (dataUrl.split(',')[1] || '')
				resolve({ base64, mime })
			}
			reader.readAsDataURL(b)
		})
	}

    btnGenerateBackground.addEventListener('click', async function () {
        if (!ensureGeminiKeyOrEnv()) { return }
		const prompt = inputPromptBackground.value.trim()
		if (!prompt) { return }
		const previousText = this.textContent
		this.disabled = true
		this.textContent = '‚è≥'

		const wasBg = inputBackgroundURL.value
		const anyEmbed = (!!(typeof chkBgBackground!=='undefined' && chkBgBackground.checked)) || (!!(typeof chkBgPose!=='undefined' && chkBgPose.checked)) || (!!(typeof chkBgSecond!=='undefined' && chkBgSecond.checked)) || (!!(typeof chkBgThird!=='undefined' && chkBgThird.checked))

		if (anyEmbed) {
			try {
				const fd = new FormData()
				fd.append('url', 'gemini://' + prompt)
				fd.append('ar', '16:9')
				// Background ref
				if (typeof chkBgBackground !== 'undefined' && chkBgBackground.checked && wasBg) {
					const { base64, mime } = await fetchUrlAsBase64(wasBg)
					fd.append('ref_background_data', base64)
					fd.append('ref_background_mime', mime)
				}
				// Pose ref
				if (typeof chkBgPose !== 'undefined' && chkBgPose.checked) {
					let poseRef = ''
					if (inputPoseURL.value) { poseRef = inputPoseURL.value } else { poseRef = 'img/poses/' + inputPose.value + '.png' }
					const { base64, mime } = await fetchUrlAsBase64(poseRef)
					fd.append('ref_pose_data', base64)
					fd.append('ref_pose_mime', mime)
				}
				// Second ref
				if (typeof chkBgSecond !== 'undefined' && chkBgSecond.checked && inputSecondURL.value) {
					const { base64, mime } = await fetchUrlAsBase64(inputSecondURL.value)
					fd.append('ref_second_data', base64)
					fd.append('ref_second_mime', mime)
				}
				// Third ref
				if (typeof chkBgThird !== 'undefined' && chkBgThird.checked && inputThirdURL.value) {
					const { base64, mime } = await fetchUrlAsBase64(inputThirdURL.value)
					fd.append('ref_third_data', base64)
					fd.append('ref_third_mime', mime)
				}
                const headers = {}
                const k = getGeminiKey()
                if (k) { headers['X-Gemini-API-Key'] = k }
                const res = await fetch('./image.php', { method: 'POST', body: fd, headers })
				const blob = await res.blob()
				const objectUrl = URL.createObjectURL(blob)
				inputBackgroundURL.value = objectUrl
				suspendPoseGeminiOnce = true
				await loadImagesAndRender()
				this.disabled = false
				this.textContent = previousText
				suspendPoseGeminiOnce = false
			} catch(e) {
				this.disabled = false
				this.textContent = previousText
				suspendPoseGeminiOnce = false
			}
			return
		}

		// Fallback: GET with refs as URLs (older path)
		let finalUrl = './image.php?url=' + encodeURIComponent('gemini://' + prompt) + '&ar=' + encodeURIComponent('16:9')
		const toProxyUrl = ensureProxyUrl
		if (typeof chkBgBackground !== 'undefined' && chkBgBackground.checked) {
			if (wasBg) {
				const bgRef = toProxyUrl(wasBg)
				if (bgRef) { finalUrl += '&ref_background=' + encodeURIComponent(bgRef) }
			}
		}
		if (typeof chkBgPose !== 'undefined' && chkBgPose.checked) {
			let poseRef = ''
			if (inputPoseURL.value) { poseRef = toProxyUrl(inputPoseURL.value) } else { poseRef = 'img/poses/' + inputPose.value + '.png' }
			if (poseRef) { finalUrl += '&ref_pose=' + encodeURIComponent(poseRef) }
		}
        if (typeof chkBgSecond !== 'undefined' && chkBgSecond.checked && inputSecondURL.value) {
            let secRef = ensureProxyUrl(inputSecondURL.value)
            if (String(inputSecondURL.value).indexOf('gemini://') === 0) { secRef += '&kind=object' }
            if (secRef) { finalUrl += '&ref_second=' + encodeURIComponent(secRef) }
        }
        if (typeof chkBgThird !== 'undefined' && chkBgThird.checked && inputThirdURL.value) {
            let thRef = ensureProxyUrl(inputThirdURL.value)
            if (String(inputThirdURL.value).indexOf('gemini://') === 0) { thRef += '&kind=object' }
            if (thRef) { finalUrl += '&ref_third=' + encodeURIComponent(thRef) }
        }
		inputBackgroundURL.value = finalUrl
		suspendPoseGeminiOnce = true
		loadImagesAndRender()
			.then(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
			.catch(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
	})

    // Generate via Gemini for SecondImage
    btnGenerateSecond.addEventListener('click', function () {
        if (!ensureGeminiKeyOrEnv()) { return }
		const prompt = inputPromptSecond.value.trim()
		if (!prompt) { return }
		const previousText = this.textContent
		this.disabled = true
		this.textContent = '‚è≥'
        inputSecondURL.value = 'gemini://' + prompt
		suspendPoseGeminiOnce = true
		loadImagesAndRender()
			.then(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
			.catch(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
	})

    // Generate via Gemini for ThirdImage
    btnGenerateThird.addEventListener('click', function () {
        if (!ensureGeminiKeyOrEnv()) { return }
		const prompt = inputPromptThird.value.trim()
		if (!prompt) { return }
		const previousText = this.textContent
		this.disabled = true
		this.textContent = '‚è≥'
        inputThirdURL.value = 'gemini://' + prompt
		suspendPoseGeminiOnce = true
		loadImagesAndRender()
			.then(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
			.catch(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
	})

    // --- Pose masking utilities ---
    const hexToRgb = function (hex) {
        try {
            const h = hex.replace('#','')
            const n = parseInt(h, 16)
            if (h.length === 6) {
                return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 }
            }
        } catch(e) { }
        return { r: 255, g: 0, b: 255 }
    }

    const samplePoseKeyFromBorders = function (img, sample) {
        const w = img.width, h = img.height
        const s = Math.max(1, Math.min(sample, Math.min(w, h)))
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const c = off.getContext('2d')
        c.drawImage(img, 0, 0)
        const get = (x,y)=>c.getImageData(x,y,1,1).data
        let sumR=0,sumG=0,sumB=0,cnt=0
        for (let x=0;x<w;x++) {
            for (let y=0;y<s;y++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
            for (let y=h-s;y<h;y++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
        }
        for (let y=0;y<h;y++) {
            for (let x=0;x<s;x++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
            for (let x=w-s;x<w;x++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
        }
        return { r: Math.round(sumR/cnt), g: Math.round(sumG/cnt), b: Math.round(sumB/cnt) }
    }

    const updatePoseMask = function () {
        poseProcessedCanvas = null
        if (!imgPose) return
        if (typeof chkPoseMask === 'undefined' || !chkPoseMask.checked) return
        const tol = parseInt(inputPoseTolerance.value || '0', 10)
        const soft = parseInt(inputPoseSoftness.value || '0', 10)
        let rgb = hexToRgb(inputPoseKeyColor.value || '#ff66cc')
        // If color is default and we have an image, auto-sample on first run
        if (!inputPoseKeyColor.dataset.sampled) {
            const sampled = samplePoseKeyFromBorders(imgPose, 5)
            rgb = sampled
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputPoseKeyColor.value = hex
            inputPoseKeyColor.dataset.sampled = '1'
        }

        const w = imgPose.width, h = imgPose.height
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const ctx2 = off.getContext('2d')
        ctx2.drawImage(imgPose, 0, 0)
        const imgData = ctx2.getImageData(0, 0, w, h)
        const data = imgData.data
        const thr = Math.max(0, tol)
        const sf = Math.max(0, soft)
        const softLo = Math.max(0, thr - sf)
        const softHi = thr + sf
        for (let i=0;i<data.length;i+=4){
            const r=data[i], g=data[i+1], b=data[i+2]
            const dr=r-rgb.r, dg=g-rgb.g, db=b-rgb.b
            const d=Math.sqrt(dr*dr+dg*dg+db*db)
            let alphaFactor = 1
            if (d <= softLo) {
                alphaFactor = 0
            } else if (d < softHi) {
                alphaFactor = (d - softLo) / (softHi - softLo)
            }
            data[i+3] = Math.round(data[i+3] * alphaFactor)
        }
        ctx2.putImageData(imgData, 0, 0)
        poseProcessedCanvas = off
    }

    const updateSecondMask = function () {
        secondProcessedCanvas = null
        if (!imgSecond) return
        if (typeof chkSecondMask === 'undefined' || !chkSecondMask.checked) return
        const tol = parseInt(inputSecondTolerance.value || '0', 10)
        const soft = parseInt(inputSecondSoftness.value || '0', 10)
        let rgb = hexToRgb(inputSecondKeyColor.value || '#ff66cc')
        if (!inputSecondKeyColor.dataset.sampled) {
            const sampled = samplePoseKeyFromBorders(imgSecond, 5)
            rgb = sampled
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputSecondKeyColor.value = hex
            inputSecondKeyColor.dataset.sampled = '1'
        }
        const w = imgSecond.width, h = imgSecond.height
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const ctx2 = off.getContext('2d')
        ctx2.drawImage(imgSecond, 0, 0)
        const imgData = ctx2.getImageData(0, 0, w, h)
        const data = imgData.data
        const thr = Math.max(0, tol)
        const sf = Math.max(0, soft)
        const softLo = Math.max(0, thr - sf)
        const softHi = thr + sf
        for (let i=0;i<data.length;i+=4){
            const r=data[i], g=data[i+1], b=data[i+2]
            const dr=r-rgb.r, dg=g-rgb.g, db=b-rgb.b
            const d=Math.sqrt(dr*dr+dg*dg+db*db)
            let alphaFactor = 1
            if (d <= softLo) {
                alphaFactor = 0
            } else if (d < softHi) {
                alphaFactor = (d - softLo) / (softHi - softLo)
            }
            data[i+3] = Math.round(data[i+3] * alphaFactor)
        }
        ctx2.putImageData(imgData, 0, 0)
        secondProcessedCanvas = off
    }

    const updateThirdMask = function () {
        thirdProcessedCanvas = null
        if (!imgThird) return
        if (typeof chkThirdMask === 'undefined' || !chkThirdMask.checked) return
        const tol = parseInt(inputThirdTolerance.value || '0', 10)
        const soft = parseInt(inputThirdSoftness.value || '0', 10)
        let rgb = hexToRgb(inputThirdKeyColor.value || '#ff66cc')
        if (!inputThirdKeyColor.dataset.sampled) {
            const sampled = samplePoseKeyFromBorders(imgThird, 5)
            rgb = sampled
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputThirdKeyColor.value = hex
            inputThirdKeyColor.dataset.sampled = '1'
        }
        const w = imgThird.width, h = imgThird.height
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const ctx2 = off.getContext('2d')
        ctx2.drawImage(imgThird, 0, 0)
        const imgData = ctx2.getImageData(0, 0, w, h)
        const data = imgData.data
        const thr = Math.max(0, tol)
        const sf = Math.max(0, soft)
        const softLo = Math.max(0, thr - sf)
        const softHi = thr + sf
        for (let i=0;i<data.length;i+=4){
            const r=data[i], g=data[i+1], b=data[i+2]
            const dr=r-rgb.r, dg=g-rgb.g, db=b-rgb.b
            const d=Math.sqrt(dr*dr+dg*dg+db*db)
            let alphaFactor = 1
            if (d <= softLo) {
                alphaFactor = 0
            } else if (d < softHi) {
                alphaFactor = (d - softLo) / (softHi - softLo)
            }
            data[i+3] = Math.round(data[i+3] * alphaFactor)
        }
        ctx2.putImageData(imgData, 0, 0)
        thirdProcessedCanvas = off
    }

    // UI events for pose masking
    if (typeof chkPoseMask !== 'undefined') {
        chkPoseMask.addEventListener('change', function(){ updatePoseMask(); render(); })
    }
    if (typeof inputPoseKeyColor !== 'undefined') {
        inputPoseKeyColor.addEventListener('input', function(){ inputPoseKeyColor.dataset.sampled='1'; updatePoseMask(); render(); })
    }
    if (typeof inputPoseTolerance !== 'undefined') {
        inputPoseTolerance.addEventListener('input', function(){ updatePoseMask(); render(); })
    }
    if (typeof inputPoseSoftness !== 'undefined') {
        inputPoseSoftness.addEventListener('input', function(){ updatePoseMask(); render(); })
    }
    if (typeof btnPoseSample !== 'undefined') {
        btnPoseSample.addEventListener('click', function(){
            if (!imgPose) return
            const sampled = samplePoseKeyFromBorders(imgPose, 5)
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputPoseKeyColor.value = hex
            inputPoseKeyColor.dataset.sampled = '1'
            updatePoseMask(); render();
        })
    }

    // UI events for second image masking
    if (typeof chkSecondMask !== 'undefined') {
        chkSecondMask.addEventListener('change', function(){ updateSecondMask(); render(); })
    }
    if (typeof inputSecondKeyColor !== 'undefined') {
        inputSecondKeyColor.addEventListener('input', function(){ inputSecondKeyColor.dataset.sampled='1'; updateSecondMask(); render(); })
    }
    if (typeof inputSecondTolerance !== 'undefined') {
        inputSecondTolerance.addEventListener('input', function(){ updateSecondMask(); render(); })
    }
    if (typeof inputSecondSoftness !== 'undefined') {
        inputSecondSoftness.addEventListener('input', function(){ updateSecondMask(); render(); })
    }
    if (typeof btnSecondSample !== 'undefined') {
        btnSecondSample.addEventListener('click', function(){
            if (!imgSecond) return
            const sampled = samplePoseKeyFromBorders(imgSecond, 5)
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputSecondKeyColor.value = hex
            inputSecondKeyColor.dataset.sampled = '1'
            updateSecondMask(); render();
        })
    }

    // UI events for third image masking
    if (typeof chkThirdMask !== 'undefined') {
        chkThirdMask.addEventListener('change', function(){ updateThirdMask(); render(); })
    }
    if (typeof inputThirdKeyColor !== 'undefined') {
        inputThirdKeyColor.addEventListener('input', function(){ inputThirdKeyColor.dataset.sampled='1'; updateThirdMask(); render(); })
    }
    if (typeof inputThirdTolerance !== 'undefined') {
        inputThirdTolerance.addEventListener('input', function(){ updateThirdMask(); render(); })
    }
    if (typeof inputThirdSoftness !== 'undefined') {
        inputThirdSoftness.addEventListener('input', function(){ updateThirdMask(); render(); })
    }
    if (typeof btnThirdSample !== 'undefined') {
        btnThirdSample.addEventListener('click', function(){
            if (!imgThird) return
            const sampled = samplePoseKeyFromBorders(imgThird, 5)
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputThirdKeyColor.value = hex
            inputThirdKeyColor.dataset.sampled = '1'
            updateThirdMask(); render();
        })
    }

	// Generate via Gemini for Pose (embed current pose as base64)
    btnGeneratePose.addEventListener('click', async function () {
        if (!ensureGeminiKeyOrEnv()) { return }
        const prompt = inputPromptPose.value.trim()
        if (!prompt) { return }
        const previousText = this.textContent
        this.disabled = true
        this.textContent = '‚è≥'
        try {
            // Determine current pose image (AI pose if selected, else base pose)
            let poseRef = ''
            if (inputPoseURL.value && inputPoseURL.value.indexOf('blob22:') !== 0) {
                poseRef = ensureProxyUrl(inputPoseURL.value)
            } else {
                poseRef = 'img/poses/' + inputPose.value + '.png'
            }
            const { base64, mime } = await fetchUrlAsBase64(poseRef)
            const fd = new FormData()
            fd.append('url', 'gemini://' + prompt)
            fd.append('pose_data', base64)
            fd.append('pose_mime', mime)
            fd.append('ar', '9:16')
            const headers = {}
            const k = getGeminiKey()
            if (k) { headers['X-Gemini-API-Key'] = k }
            const res = await fetch('./image.php', { method: 'POST', body: fd, headers })
            const blob = await res.blob()
            const objectUrl = URL.createObjectURL(blob)
            inputPoseURL.value = objectUrl
            await loadImagesAndRender()
            this.disabled = false
            this.textContent = previousText
        } catch(e) {
            this.disabled = false
            this.textContent = previousText
        }
    })

	// Clicking the pose input should revert to normal pose selection
	if (typeof inputPose !== 'undefined') {
		inputPose.addEventListener('click', function(){
			if (inputPoseURL.value) {
				inputPoseURL.value = ''
				if (typeof inputPoseKeyColor !== 'undefined') { inputPoseKeyColor.dataset.sampled = '' }
				loadImagesAndRender()
			}
		})
	}


    document.querySelectorAll('[data-image-target]').forEach((input) => input.onchange = function (e) {
        const inp = eId(e.target.getAttribute('data-image-target'))
        inp.value = URL.createObjectURL(this.files[0]);
        loadImagesAndRender()
    })

    loadFromURL()
    syncAllTransformNumbers()
    loadImagesAndRender()
    populateAssetLists()

    tf_inputSecondURL_s.value = 27
    if (typeof syncTransformNumbersFor === 'function') { syncTransformNumbersFor(inputSecondURL.id) }



    document.querySelectorAll('input').forEach((input) => input.addEventListener('input', render))
    document.querySelectorAll('input').forEach((input) => input.addEventListener('change', render))
    document.querySelectorAll('input').forEach((input) => input.addEventListener('keyup', render))
    document.querySelectorAll('[data-force-imageload]').forEach((input) => input.addEventListener('change', loadImagesAndRender))
    document.querySelectorAll('[data-force-imageload]').forEach((input) => input.addEventListener('keyup', loadImagesAndRender))

    // UI Level toggle logic
    const setUiLevel = function (level) {
        const lvl = parseInt(level, 10) || 0
        document.body.dataset.uiLevel = String(lvl)
        document.querySelectorAll('.ui-level-0').forEach(function(el){ el.hidden = false })
        document.querySelectorAll('.ui-level-1, .ui-level-2').forEach(function(el){
            const required = el.classList.contains('ui-level-2') ? 2 : 1
            el.hidden = lvl < required
        })
        try { localStorage.setItem('uiLevel', String(lvl)) } catch(e) { }

        // In Simple mode, auto-expand Background prompt (P) and hide others via classes already
        try {
            if (typeof spanPromptBackground !== 'undefined') {
                spanPromptBackground.style.display = (lvl === 0) ? 'inline' : 'none'
            }
        } catch(e) { /* ignore */ }
    }
    if (typeof selectUiLevel !== 'undefined') {
        selectUiLevel.addEventListener('change', function(){ setUiLevel(this.value) })
        let stored = '0'
        try { stored = localStorage.getItem('uiLevel') || '0' } catch(e) { stored = '0' }
        selectUiLevel.value = stored
        setUiLevel(stored)
    }

    // --- Selection & Keyboard movement ---
    var selectedId = ''
    const clampNumberToRange = function(v, min, max){
        const n = parseFloat(v)
        const lo = parseFloat(min)
        const hi = parseFloat(max)
        return Math.max(lo, Math.min(hi, n))
    }
    const getTransformContainerById = function (id) {
        if (!id) return null
        if (id === inputBackgroundURL.id) return spanBackgroundPosition
        if (id === inputPose.id) return spanPosesPosition
        if (id === inputText1.id) return spanText1Position
        if (id === inputText2.id) return spanText2Position
        if (id === inputSecondURL.id) return spanSecondPosition
        if (id === inputThirdURL.id) return spanThirdPosition
        return null
    }
    const getSectionContainerById = function(id){
        const sub = getTransformContainerById(id)
        if (!sub) return null
        // Highlight the whole section container (panel)
        return sub.closest('.panel') || sub.closest('section') || sub.closest('div')
    }
    const clearSelectedUi = function(){
        document.querySelectorAll('.selectedControl').forEach(function(el){ el.classList.remove('selectedControl') })
        document.querySelectorAll('.selectedSection').forEach(function(el){ el.classList.remove('selectedSection') })
    }
    const setSelected = function(id){
        selectedId = id || ''
        clearSelectedUi()
        const cont = getTransformContainerById(selectedId)
        if (cont) { cont.classList.add('selectedControl') }
        const sec = getSectionContainerById(selectedId)
        if (sec) { sec.classList.add('selectedSection') }
        render()
    }
    const toggleSelect = function(id){
        if (!id) { setSelected(''); return }
        if (selectedId === id) { setSelected('') } else { setSelected(id) }
    }
    const adjustSelected = function(dx, dy){
        if (!selectedId) return
        const ix = eId('tf_' + selectedId + '_x')
        const iy = eId('tf_' + selectedId + '_y')
        if (!ix || !iy) return
        const stepx = dx
        const stepy = dy
        ix.value = clampNumberToRange(parseFloat(ix.value) + stepx, ix.min, ix.max)
        iy.value = clampNumberToRange(parseFloat(iy.value) + stepy, iy.min, iy.max)
        const nx = eId('tfn_' + selectedId + '_x')
        const ny = eId('tfn_' + selectedId + '_y')
        if (nx) nx.value = ix.value
        if (ny) ny.value = iy.value
        render()
    }
    const adjustRotationSelected = function(dRot){
        if (!selectedId) return
        const ir = eId('tf_' + selectedId + '_r')
        if (!ir) return
        ir.value = clampNumberToRange(parseFloat(ir.value) + dRot, ir.min, ir.max)
        const nr = eId('tfn_' + selectedId + '_r')
        if (nr) nr.value = ir.value
        render()
    }
    const adjustScaleSelected = function(dScale){
        if (!selectedId) return
        const is = eId('tf_' + selectedId + '_s')
        if (!is) return
        is.value = clampNumberToRange(parseFloat(is.value) + dScale, is.min, is.max)
        const ns = eId('tfn_' + selectedId + '_s')
        if (ns) ns.value = is.value
        render()
    }
    document.addEventListener('keydown', function(e){
        const k = e.key
        const moveStep = e.shiftKey ? 1 : 10
        const rotStep = e.shiftKey ? 1 : 5
        const sclStep = e.shiftKey ? 1 : 10
        const ae = document.activeElement
        if (ae && (ae.isContentEditable || (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.tagName === 'SELECT'))) { return }
        if (k === '1') { toggleSelect(inputBackgroundURL.id); return }
        if (k === '2') { toggleSelect(inputPose.id); return }
        if (k === '3') { toggleSelect(inputText1.id); return }
        if (k === '4') { toggleSelect(inputText2.id); return }
        if (k === '5') { toggleSelect(inputSecondURL.id); return }
        if (k === '6') { toggleSelect(inputThirdURL.id); return }
        if (k >= '0' && k <= '9') { setSelected(''); return }
        if (!selectedId) return
        if (k === 'ArrowLeft') { e.preventDefault(); adjustSelected(-moveStep, 0); return }
        if (k === 'ArrowRight') { e.preventDefault(); adjustSelected(moveStep, 0); return }
        if (k === 'ArrowUp') { e.preventDefault(); adjustSelected(0, -moveStep); return }
        if (k === 'ArrowDown') { e.preventDefault(); adjustSelected(0, moveStep); return }
        // WASD
        if (k === 'a' || k === 'A') { e.preventDefault(); adjustSelected(-moveStep, 0); return }
        if (k === 'd' || k === 'D') { e.preventDefault(); adjustSelected(moveStep, 0); return }
        if (k === 'w' || k === 'W') { e.preventDefault(); adjustSelected(0, -moveStep); return }
        if (k === 's' || k === 'S') { e.preventDefault(); adjustSelected(0, moveStep); return }
        // Rotation: Q/E
        if (k === 'q' || k === 'Q') { e.preventDefault(); adjustRotationSelected(-rotStep); return }
        if (k === 'e' || k === 'E') { e.preventDefault(); adjustRotationSelected(rotStep); return }
        // Scale: +/- (support Numpad + and - as well)
        if (k === '+' ) { e.preventDefault(); adjustScaleSelected(sclStep); return }
        if (k === '-') { e.preventDefault(); adjustScaleSelected(-sclStep); return }
        // Scale: R/F as alternative shortcuts
        if (k === 'r' || k === 'R') { e.preventDefault(); adjustScaleSelected(sclStep); return }
        if (k === 'f' || k === 'F') { e.preventDefault(); adjustScaleSelected(-sclStep); return }
    })

    // --- Canvas click selection (hit-testing and cycling front-to-back) ---
    const getTextSize = function(text){
        try {
            ctx.save()
            ctx.font = "64pt Impact"
            const m = ctx.measureText(text)
            const h = (m.actualBoundingBoxAscent || 40) + (m.actualBoundingBoxDescent || 10)
            const w = m.width || 0
            ctx.restore()
            return { w: w, h: h }
        } catch(e) {
            return { w: 0, h: 80 }
        }
    }
    const getLayersFrontToBack = function(){
        const layers = []
        // Front-most first in this list
        // Text1 (now left/start)
        if (typeof inputText1 !== 'undefined') {
            const s = getTextSize(inputText1.value)
            layers.push({ kind:'text', id: inputText1.id, x: 50, y: canvas.height - 50, w: s.w, h: s.h, tl: false, align: 'start', baseline: 'bottom' })
        }
        // Text2 (now right/end)
        if (typeof inputText2 !== 'undefined') {
            const s = getTextSize(inputText2.value)
            layers.push({ kind:'text', id: inputText2.id, x: canvas.width - 50, y: canvas.height - 50, w: s.w, h: s.h, tl: false, align: 'end', baseline: 'bottom' })
        }
        // SecondImage
        if (imgSecond) {
            layers.push({ kind:'image', id: inputSecondURL.id, x: 0, y: 0, w: imgSecond.width, h: imgSecond.height, tl: true })
        }
        // Pose
        if (imgPose) {
            const w = imgPoseWidth
            const source = (typeof chkPoseMask !== 'undefined' && chkPoseMask.checked && poseProcessedCanvas) ? poseProcessedCanvas : imgPose
            const h = w * source.height / source.width
            layers.push({ kind:'image', id: inputPose.id, x: canvas.width * 0.1, y: canvas.height * 0.3, w, h, tl: false })
        }
        // ThirdImage
        if (imgThird) {
            layers.push({ kind:'image', id: inputThirdURL.id, x: 0, y: 0, w: imgThird.width, h: imgThird.height, tl: false })
        }
        // Background
        if (imgBackground) {
            const w = Math.min(canvas.width, imgBackground.width)
            const h = w * imgBackground.height / imgBackground.width
            layers.push({ kind:'image', id: inputBackgroundURL.id, x: 0, y: 0, w, h, tl: false })
        }
        return layers
    }
    const getTransformForId = function(id){
        const tx = parseFloat((eId('tf_' + id + '_x') || { value: 0 }).value || 0)
        const ty = parseFloat((eId('tf_' + id + '_y') || { value: 0 }).value || 0)
        const r = parseFloat((eId('tf_' + id + '_r') || { value: 0 }).value || 0)
        const s = parseFloat((eId('tf_' + id + '_s') || { value: 100 }).value || 100) * 0.01
        const fh = (eId('tf_' + id + '_h') || { checked: false }).checked ? -1 : 1
        const fv = (eId('tf_' + id + '_v') || { checked: false }).checked ? -1 : 1
        return { tx, ty, r, s, fh, fv }
    }
    const rotatePoint = function(pt, angleRad){
        const c = Math.cos(angleRad), si = Math.sin(angleRad)
        return { x: pt.x * c - pt.y * si, y: pt.x * si + pt.y * c }
    }
    const worldToLocal = function(px, py, desc){
        // Inverse of forward chain:
        // pW = Tdesc ‚àò Ttf ‚àò [T(+w/2,+h/2) if !tl] ‚àò R ‚àò S ‚àò Flip ‚àò [T(-w/2,-h/2) if !tl] (pL)
        // pL = [T(+w/2,+h/2) if !tl]^{-1} ‚àò Flip^{-1} ‚àò S^{-1} ‚àò R^{-1} ‚àò [T(+w/2,+h/2) if !tl] ‚àò Ttf^{-1} ‚àò Tdesc^{-1} (pW)
        let p = { x: px, y: py }
        const tr = getTransformForId(desc.id)
        // Undo outer translations first
        p.x -= desc.x; p.y -= desc.y
        p.x -= tr.tx; p.y -= tr.ty
        if (!desc.tl) { p.x -= desc.w / 2; p.y -= desc.h / 2 }
        // Undo rotation
        p = rotatePoint(p, -tr.r * Math.PI / 180)
        // Undo scale
        if (tr.s !== 0) { p.x = p.x / tr.s; p.y = p.y / tr.s }
        // Undo flips
        p.x = p.x / tr.fh; p.y = p.y / tr.fv
        if (!desc.tl) { p.x += desc.w / 2; p.y += desc.h / 2 }
        return p
    }
    const isHit = function(px, py, desc){
        let lp = worldToLocal(px, py, desc)
        if (desc.kind === 'text') {
            let offX = 0, offY = 0
            if (desc.align === 'center') offX = -desc.w / 2
            else if (desc.align === 'end' || desc.align === 'right') offX = -desc.w
            else offX = 0
            if (desc.baseline === 'bottom' || desc.baseline === 'ideographic') offY = -desc.h
            else if (desc.baseline === 'middle') offY = -desc.h / 2
            else offY = 0
            lp = { x: lp.x - offX, y: lp.y - offY }
        }
        return lp.x >= 0 && lp.y >= 0 && lp.x <= desc.w && lp.y <= desc.h
    }
    let lastClickPos = null
    const getCanvasXY = function(evt){
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY
        }
    }
    var dragState = null
    canvas.addEventListener('mousedown', function(e){
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        const px = (e.clientX - rect.left) * scaleX
        const py = (e.clientY - rect.top) * scaleY
        const layers = getLayersFrontToBack()
        const hits = []
        for (let i = 0; i < layers.length; i++) {
            const d = layers[i]
            if (isHit(px, py, d)) { hits.push(d.id) }
        }
        if (e.button === 0) {
            if (!hits.length) {
                setSelected('')
                lastClickPos = { x: px, y: py }
                // still allow starting a drag move even with no selection
            } else {
                const same = lastClickPos && Math.abs(lastClickPos.x - px) < 3 && Math.abs(lastClickPos.y - py) < 3
                let nextIdx = 0
                if (same) {
                    const currentIdx = hits.indexOf(selectedId)
                    if (currentIdx >= 0) { nextIdx = (currentIdx + 1) % hits.length } else { nextIdx = 0 }
                }
                setSelected(hits[nextIdx])
                lastClickPos = { x: px, y: py }
            }
        } else if ((e.button === 1 || e.button === 2) && !selectedId && hits.length) {
            // If no selection, pick the topmost under cursor for MMB/RMB; otherwise keep selection
            setSelected(hits[0])
        }

        // Start drag depending on mouse button
        // 0: move, 2: rotate by y, 1: scale by y
        let mode = 'move'
        if (e.button === 2) mode = 'rotate'
        if (e.button === 1) mode = 'scale'
        dragState = { mode: mode, lastX: px, lastY: py }
        e.preventDefault()
    })
    const handleDragMove = function(e){
        if (!dragState || !selectedId) return
        const p = getCanvasXY(e)
        const dx = p.x - dragState.lastX
        const dy = p.y - dragState.lastY
        const fine = e.shiftKey ? 0.1 : 1
        if (dragState.mode === 'move') {
            adjustSelected(dx * fine, dy * fine)
        } else if (dragState.mode === 'rotate') {
            // Use both axes for smoother rotation control
            const rotDelta = (dx + dy) * (e.shiftKey ? 0.1 : 0.5)
            adjustRotationSelected(rotDelta)
        } else if (dragState.mode === 'scale') {
            adjustScaleSelected(-dy * (e.shiftKey ? 0.2 : 1))
        }
        dragState.lastX = p.x
        dragState.lastY = p.y
        e.preventDefault()
    }
    canvas.addEventListener('mousemove', handleDragMove)
    document.addEventListener('mousemove', handleDragMove)
    const endDrag = function(){ dragState = null }
    canvas.addEventListener('mouseup', endDrag)
    document.addEventListener('mouseup', endDrag)
    canvas.addEventListener('mouseleave', function(){ /* keep dragging across document for RMB/MMB */ })
    canvas.addEventListener('contextmenu', function(e){ e.preventDefault() })
    // Inline text editing on double click
    var textEditorEl = null
    var textEditorTargetId = ''
    const ensureTextEditor = function(){
        if (textEditorEl) return textEditorEl
        const inp = document.createElement('input')
        inp.type = 'text'
        inp.id = 'canvasTextEditor'
        inp.style.position = 'fixed'
        inp.style.zIndex = '1000'
        inp.style.padding = '6px 8px'
        inp.style.border = '1px solid rgba(0,0,0,0.3)'
        inp.style.borderRadius = '0px'
        inp.style.background = '#fff'
        inp.style.color = '#000'
        inp.style.boxShadow = '0 8px 18px rgba(0,0,0,0.12)'
        inp.style.display = 'none'
        inp.addEventListener('keydown', function(ev){
            if (ev.key === 'Enter') { commitTextEdit(); ev.preventDefault() }
            if (ev.key === 'Escape') { cancelTextEdit(); ev.preventDefault() }
        })
        inp.addEventListener('blur', function(){ commitTextEdit() })
        document.body.appendChild(inp)
        textEditorEl = inp
        return inp
    }
    const openTextEditorFor = function(targetId, clientX, clientY){
        const inp = ensureTextEditor()
        textEditorTargetId = targetId || ''
        const src = eId(textEditorTargetId)
        if (!src) return
        inp.value = src.value || ''
        inp.style.left = Math.round(clientX + 8) + 'px'
        inp.style.top = Math.round(clientY + 8) + 'px'
        inp.style.display = 'block'
        setTimeout(function(){ try { inp.focus(); inp.select(); } catch(e){} }, 0)
    }
    const hideTextEditor = function(){ if (textEditorEl) { textEditorEl.style.display = 'none' } }
    const commitTextEdit = function(){
        if (!textEditorEl || !textEditorTargetId) { hideTextEditor(); return }
        const dst = eId(textEditorTargetId)
        if (dst && dst.value !== textEditorEl.value) { dst.value = textEditorEl.value }
        hideTextEditor(); render()
    }
    const cancelTextEdit = function(){ hideTextEditor() }
    // Helpers: cycle Pose and Background on double-click
    const cyclePose = function(){
        try {
            const isAi = !!(inputPoseURL && inputPoseURL.value)
            if (isAi && Array.isArray(generatedPosesData) && generatedPosesData.length > 0) {
                const cur = String(inputPoseURL.value || '')
                let idx = -1
                for (let i=0;i<generatedPosesData.length;i++){
                    const u = String(generatedPosesData[i].url || '')
                    if (!u) continue
                    if (cur.indexOf(u) > -1 || cur.endsWith('/' + u.split('/').pop())) { idx = i; break }
                }
                const next = (idx >= 0) ? ((idx + 1) % generatedPosesData.length) : 0
                if (typeof chkPoseMask !== 'undefined') { chkPoseMask.checked = true }
                if (typeof inputPoseTolerance !== 'undefined') { inputPoseTolerance.value = 69 }
                if (typeof inputPoseSoftness !== 'undefined') { inputPoseSoftness.value = 69 }
                if (typeof inputPoseKeyColor !== 'undefined') { inputPoseKeyColor.dataset.sampled = '' }
                inputPoseURL.value = generatedPosesData[next].url
                suspendPoseGeminiOnce = true
                loadImagesAndRender().then(function(){ suspendPoseGeminiOnce = false }).catch(function(){ suspendPoseGeminiOnce = false })
            } else {
                const count = (Array.isArray(normalPosesData) && normalPosesData.length > 0) ? normalPosesData.length : (parseInt(inputPose.max,10) + 1 || posesCount)
                const curIdx = parseInt(inputPose.value || '0', 10) || 0
                const nextIdx = (curIdx + 1) % Math.max(1, count)
                inputPose.value = nextIdx
                if (inputPoseURL) { inputPoseURL.value = '' }
                loadImagesAndRender()
            }
        } catch(e) { /* ignore */ }
    }
    const cycleBackground = function(){
        try {
            if (!Array.isArray(generatedBackgroundsData) || generatedBackgroundsData.length === 0) return
            const cur = String((inputBackgroundURL && inputBackgroundURL.value) || '')
            let idx = -1
            for (let i=0;i<generatedBackgroundsData.length;i++){
                const u = String(generatedBackgroundsData[i].url || '')
                if (!u) continue
                if (cur.indexOf(u) > -1 || cur.endsWith('/' + u.split('/').pop())) { idx = i; break }
            }
            const next = (idx >= 0) ? ((idx + 1) % generatedBackgroundsData.length) : 0
            inputBackgroundURL.value = generatedBackgroundsData[next].url
            loadImagesAndRender()
        } catch(e) { /* ignore */ }
    }
    canvas.addEventListener('dblclick', function(e){
        const p = getCanvasXY(e)
        const layers = getLayersFrontToBack()
        // Text editing takes precedence
        for (let i = 0; i < layers.length; i++) {
            const d = layers[i]
            if (d.kind === 'text' && isHit(p.x, p.y, d)) {
                setSelected(d.id)
                openTextEditorFor(d.id, e.clientX, e.clientY)
                e.preventDefault()
                return
            }
        }
        // Otherwise, hit-test topmost and cycle pose/background
        for (let i = 0; i < layers.length; i++) {
            const d = layers[i]
            if (!isHit(p.x, p.y, d)) continue
            if (d.id === inputPose.id) {
                setSelected(d.id)
                cyclePose()
                e.preventDefault()
                return
            }
            if (d.id === inputBackgroundURL.id) {
                setSelected(d.id)
                cycleBackground()
                e.preventDefault()
                return
            }
            break
        }
    })
    // Hover cursor hint when over text
    canvas.addEventListener('mousemove', function(e){
        if (dragState) return
        const p = getCanvasXY(e)
        const layers = getLayersFrontToBack()
        let overText = false
        for (let i = 0; i < layers.length; i++) {
            const d = layers[i]
            if (d.kind === 'text' && isHit(p.x, p.y, d)) { overText = true; break }
        }
        canvas.style.cursor = overText ? 'text' : ''
    })
    // Mouse wheel zoom
    canvas.addEventListener('wheel', function(e){
        if (!selectedId) return
        const factor = e.shiftKey ? 0.5 : 2
        const delta = -Math.sign(e.deltaY) * factor * 5
        adjustScaleSelected(delta)
        e.preventDefault()
    }, { passive: false })
    // Touch support (single finger = move)
    canvas.addEventListener('touchstart', function(e){
        if (!e.touches || e.touches.length < 1) return
        const t = e.touches[0]
        const p = getCanvasXY(t)
        dragState = { mode: 'move', lastX: p.x, lastY: p.y }
        // Do a quick hit-test to select something under finger if not already selected
        const layers = getLayersFrontToBack()
        for (let i = 0; i < layers.length; i++) {
            const d = layers[i]
            if (isHit(p.x, p.y, d)) { setSelected(d.id); break }
        }
        e.preventDefault()
    }, { passive: false })
    canvas.addEventListener('touchmove', function(e){
        if (!dragState || !selectedId || !e.touches || e.touches.length < 1) return
        const t = e.touches[0]
        const p = getCanvasXY(t)
        const dx = p.x - dragState.lastX
        const dy = p.y - dragState.lastY
        adjustSelected(dx, dy)
        dragState.lastX = p.x
        dragState.lastY = p.y
        e.preventDefault()
    }, { passive: false })
    canvas.addEventListener('touchend', function(){ dragState = null })
    canvas.addEventListener('touchcancel', function(){ dragState = null })
    // (Canvas focus gating removed)

    // download it

    btnDownload.addEventListener('click', function (e) {
        setSelected('')
        render()
        const canvasUrl = canvas.toDataURL('image/jpeg', 1.0)
        const fileName = buildDownloadFilename()
        const createEl = document.createElement('a')
        createEl.href = canvasUrl
        createEl.download = fileName
        createEl.click()
        createEl.remove()

        // Also persist result to backend (async, non-blocking)
        try {
            canvas.toBlob(function(blob){
                if (!blob) return
                const fd = new FormData()
                fd.append('action', 'save_result')
                fd.append('filename', fileName)
                // Serialize current inputs as JSON
                const params = collectCurrentParams()
                const obj = {}
                params.forEach((v, k) => { obj[k] = v })
                fd.append('settings', JSON.stringify({ params: obj, ts: new Date().toISOString() }))
                fd.append('image', blob, fileName)
                fetch('./assets.php', { method: 'POST', body: fd })
                    .then(r => r.json())
                    .then(() => { try { populateAssetLists() } catch(e){} })
                    .catch(() => { /* ignore */ })
            }, 'image/jpeg', 0.95)
        } catch(e) { /* ignore */ }
    })

    // Deletion of generated assets (one-by-one)
    function deleteGeneratedAsset(a, b, c) {
        try {
            // Support both signatures: (type, url) and (event, type, url)
            var evt = (typeof a === 'object' && a && typeof a.type === 'string') ? a : null;
            var type = (evt ? b : a);
            var url = (evt ? c : b);
            const parts = String(url || '').split('/');
            const fname = parts[parts.length - 1];
            if (!fname) { return; }
            const skipConfirm = !!(evt && evt.shiftKey);
            if (!skipConfirm && !confirm('Delete this ' + type + '?')) { return; }
            const body = 'action=delete&type=' + encodeURIComponent(type) + '&file=' + encodeURIComponent(fname)
            fetch('./assets.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body
            })
                .then(r => r.json())
                .then(res => {
                    if (res && res.success) {
                        // Clear current selection if it was the deleted one
                        if (type === 'pose' && (inputPoseURL.value || '').endsWith('/' + fname)) {
                            inputPoseURL.value = '';
                            inputPoseKeyColor.dataset.sampled = '';
                            loadImagesAndRender();
                        }
                        if (type === 'background' && (inputBackgroundURL.value || '').endsWith('/' + fname)) {
                            inputBackgroundURL.value = '';
                            loadImagesAndRender();
                        }
                        if (type === 'object') {
                            if ((inputSecondURL.value || '').endsWith('/' + fname)) { inputSecondURL.value = ''; }
                            if ((inputThirdURL.value || '').endsWith('/' + fname)) { inputThirdURL.value = ''; }
                            loadImagesAndRender();
                        }
                        populateAssetLists();
                    } else {
                        alert('Delete failed');
                    }
                })
                .catch(() => alert('Delete failed'))
        } catch (e) { /* ignore */ }
    }

    // Restore a saved result's configuration
    function restoreResultSettings(jsonUrl){
        if (!jsonUrl) return
        fetch(jsonUrl)
            .then(r => r.json())
            .then(data => {
                try {
                    const params = (data && data.settings && data.settings.params) ? data.settings.params : (data && data.params ? data.params : null)
                    if (!params) return
                    document.querySelectorAll('input').forEach(function(input){
                        if (typeof params[input.id] === 'undefined') return
                        if (input.type === 'file') {
                            // ignore
                        } else if (input.type === 'checkbox') {
                            input.checked = String(params[input.id]) === 'true'
                        } else {
                            input.value = params[input.id]
                        }
                    })
                    syncAllTransformNumbers()
                    loadImagesAndRender()
                } catch(e) { /* ignore */ }
            })
            .catch(() => { /* ignore */ })
    }

</script>

<script src="theme.js"></script>

</html>