<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Youtube Thumbnail Generator</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        img {
            border: 1px solid black;
        }

        canvas {
            background-color: black;
        }

        .highlight {
            background-color: green;
        }

        .assetItem { position: relative; display: inline-block; margin: 2px; }
        .assetItem img { display: block; }
        .deleteBtn { position: absolute; top: 2px; right: 2px; background: rgba(0,0,0,0.6); color: #fff; border: none; border-radius: 0px; cursor: pointer; font-size: 12px; line-height: 1; padding: 2px 4px; }
        .selectedControl { background: rgba(255, 192, 0, 0.18); outline: 2px solid rgb(255, 192, 0); outline-offset: 2px; }
        .selectedSection { background: rgba(255, 192, 0, 0.18); outline: 3px solid rgb(255, 192, 0); }
        .canvasFocused { outline: 3px solid #ffea00; }
    </style>
</head>

<body>
    <header class="topbar">
        <div class="topbar__left">
            <img class="topbar__logo" src="img/logo.svg" alt="Werteherren" />
        </div>
        <div class="topbar__right">
            <span class="topbar__title">Youtube Thumbnail Generator</span>
        </div>
    </header>
    <main class="layout">
    <aside class="sidebar">
    <section class="panel glass" id="card-background">
        <div class="ui-level-0"><a href="https://unsplash.com/s/photos/werte?license=free" target="unsplash">Background</a>: <input
                id="inputBackgroundURL" type="text" size="10" data-force-imageload><input type="file"
                data-image-target="inputBackgroundURL" /><span id="spanBackgroundPosition" class="ui-level-1"></span><button id="btnPromptBackground" class="ui-level-0" title="Generate with prompt">AI</button><span id="spanPromptBackground" class="ui-level-0" style="display:none;">
                <div class="prompt-label">Gemini AI</div>
                <textarea id="inputPromptBackground" rows="5" class="prompt-textarea" placeholder="Describe background..."></textarea>
                <button id="btnGenerateBackground" title="Generate background image">Generate</button>
                <label class="ui-level-1" title="Include Background as reference"><input id="chkBgBackground" type="checkbox"> Background</label> <label class="ui-level-1" title="Include Pose as reference"><input id="chkBgPose" type="checkbox"> Pose</label> <label class="ui-level-1" title="Include SecondImage as reference"><input id="chkBgSecond" type="checkbox"> SecondImage</label> <label class="ui-level-1" title="Include ThirdImage as reference"><input id="chkBgThird" type="checkbox"> ThirdImage</label>
                </span></div>
    </section>

    <section class="panel glass" id="card-pose">
        <div class="ui-level-0">Pose: <input id="inputPose" step="1" type="number" min="0" max="30" data-force-imageload /><button
                title="chaos" onclick="inputPoseURL.value=''; if (typeof inputPoseKeyColor!=='undefined'){ inputPoseKeyColor.dataset.sampled=''; } randomizeInputByMinMax(inputPose, true); loadImagesAndRender()">c</button><span
                id="spanPoses"></span><span id="spanPosesPosition" class="ui-level-1"></span><button id="btnPromptPose" class="ui-level-0" title="Generate with prompt">AI</button><span id="spanPromptPose" class="ui-level-1" style="display:none;">
                <div class="prompt-label">Gemini AI</div>
                <textarea id="inputPromptPose" rows="5" class="prompt-textarea" placeholder="Describe pose edit...">Using the provided image of a man in a suit, give him a magic hat. Ensure the man's face and features remain completely unchanged. The background has to be #ff00ff.</textarea>
                <button id="btnGeneratePose" title="Generate pose image">Generate</button> <label title="Apply chroma key to pose"><input id="chkPoseMask" type="checkbox" checked> Mask</label> <button id="btnPoseSample" title="Sample key color from borders of pose">Sample</button> Color: <input id="inputPoseKeyColor" type="color" value="#ff00ff"> Tolerance: <input id="inputPoseTolerance" type="range" min="-1" max="255" value="0"> <br>Softness: <input id="inputPoseSoftness" type="range" min="-1" max="255" value="0"></span><input id="inputPoseURL" type="hidden" data-force-imageload /></div>
    </section>

    <section class="panel glass" id="card-text1">
        <div class="ui-level-0"> Text1: <input id="inputText1" type="text"><span id="spanText1Position" class="ui-level-1"></span></div>
    </section>

    <section class="panel glass" id="card-text2">
        <div class="ui-level-0">Text2: <input id="inputText2" type="text"><span id="spanText2Position" class="ui-level-1"></span></div>
    </section>

    <section class="panel glass ui-level-1" id="card-second">
        <div class="ui-level-1"><a href="https://library.techsmith.com/en/camtasia/assets/Graphic/Photo">SecondImage</a>: <input
                id="inputSecondURL" type="text" size="10" data-force-imageload><input type="file"
                data-image-target="inputSecondURL" /><span id="spanSecondPosition"></span><button id="btnPromptSecond" title="Generate with prompt">AI</button><span id="spanPromptSecond" style="display:none;">
                <div class="prompt-label">Gemini AI</div>
                <textarea id="inputPromptSecond" rows="4" class="prompt-textarea" placeholder="Describe second image..."></textarea>
                <button id="btnGenerateSecond" title="Generate second image">Generate</button> <label title="Apply chroma key to SecondImage"><input id="chkSecondMask" type="checkbox" checked> Mask</label> <button id="btnSecondSample" title="Sample key color from borders of SecondImage">Sample</button> Color: <input id="inputSecondKeyColor" type="color" value="#ff00ff"> Tolerance: <input id="inputSecondTolerance" type="range" min="-1" max="255" value="0"> <br>Softness: <input id="inputSecondSoftness" type="range" min="-1" max="255" value="0"></span></div>
    </section>

    <section class="panel glass ui-level-1" id="card-third">
        <div class="ui-level-1">ThirdImage: <input id="inputThirdURL" type="text" size="10" data-force-imageload><input type="file"
                data-image-target="inputThirdURL" /><span id="spanThirdPosition"></span><button id="btnPromptThird" title="Generate with prompt">AI</button><span id="spanPromptThird" style="display:none;">
                <div class="prompt-label">Gemini AI</div>
                <textarea id="inputPromptThird" rows="4" class="prompt-textarea" placeholder="Describe third image..."></textarea>
                <button id="btnGenerateThird" title="Generate third image">Generate</button> <label title="Apply chroma key to ThirdImage"><input id="chkThirdMask" type="checkbox" checked> Mask</label> <button id="btnThirdSample" title="Sample key color from borders of ThirdImage">Sample</button> Color: <input id="inputThirdKeyColor" type="color" value="#ff00ff"> Tolerance: <input id="inputThirdTolerance" type="range" min="-1" max="255" value="0"> <br>Softness: <input id="inputThirdSoftness" type="range" min="-1" max="255" value="0"></span></div>
    </section>

    <section class="panel glass" id="card-canvascolor">
        <div class="ui-level-0">Canvas color: <input id="inputCanvasColor" type="color" value="#000000"></div>
    </section>

    
    </aside>
    <section id="canvas-wrap" class="canvas-wrap">
        <canvas width="1280" height="720" id="canvas"></canvas>
        <div class="actions-bar" id="card-actions">
            <div class="actions__row">
                <button id="btnDownload" class="ui-level-0 btn btn--primary">Download</button>
                <a id="btnDeeplink" class="ui-level-0" href="">DeepLink</a>
                <a id="btnReset" class="ui-level-0" href="?">Reset All</a>
            </div>
        </div>
    </section>

    <div id="poseList" class="ui-level-1">
        <div class="thumbs-header"><span class="thumbs-title">Poses</span></div>
        <div id="poseListItems"></div>
    </div>
    <div id="generatedPoseList" class="ui-level-1">
        <div class="thumbs-header"><span class="thumbs-title">AI Poses</span> <button id="btnShowAllGeneratedPoses" class="btn">Show all</button></div>
        <div id="generatedPoseListItems"></div>
    </div>
    <div id="generatedBackgroundList" class="ui-level-1">
        <div class="thumbs-header"><span class="thumbs-title">AI Backgrounds</span> <button id="btnShowAllGeneratedBackgrounds" class="btn">Show all</button></div>
        <div id="generatedBackgroundListItems"></div>
    </div>
    <div id="resultsList" class="ui-level-1">
        <div class="thumbs-header"><span class="thumbs-title">Results</span> <button id="btnShowAllResults" class="btn">Show all</button></div>
        <div id="resultsListItems"></div>
    </div>
    </main>

    <footer class="footer">
        <div class="footer__left">
            <span>by Alexander Thurn - Open source</span>
            <a href="https://github.com/alexanderthurn/youtube-thumbnail-generator" target="_blank" rel="noopener">GitHub</a>
        </div>
        <div class="footer__right">
            <label class="ui-level-2"><input type="checkbox" id="toggleReducedMotion"> Reduced motion</label>
            <label>Mode:
                <select id="selectUiLevel">
                    <option value="0">Simple</option>
                    <option value="1">Advanced</option>
                    <option value="2">Expert</option>
                </select>
            </label>
        </div>
    </footer>
</body>

<script type="text/javascript">
    const eId = function (id) { return document.getElementById(id); };

    const posesCount = 28
    const urlBackground = ''
    const urlAB = ''

    inputText1.value = 'Welt'
    inputText2.value = 'Hallo'
    inputPose.value = Math.floor(Math.random() * posesCount)

    var imgBackground = null
    var imgLogo = null
    var imgPose = null
    var imgSecond = null
    var imgThird = null
    var poseProcessedCanvas = null
    var secondProcessedCanvas = null
    var thirdProcessedCanvas = null

    // Thumbnail pagination size (change here to adjust page size)
    const THUMBS_PAGE_SIZE = 5

    // Asset list state
    var normalPosesData = []
    var generatedPosesData = []
    var generatedBackgroundsData = []
    var resultsData = []
    var showAllGeneratedPoses = false
    var showAllGeneratedBackgrounds = false
    var showAllResults = false


    //inputBackgroundURL.value = urlBackground
    inputSecondURL.value = urlAB
    inputPose.max = posesCount - 1
    const ctx = canvas.getContext("2d");
    const colorBrand = 'rgb(255, 192, 0)'
    const colorBackground = 'black'
    const colorLogo = 'black'
    const paddingBackgroundLogoPixel = 10
    const imgPoseWidth = canvas.width * 0.5

    // One-time flag to avoid re-generating Pose when generating other images
    var suspendPoseGeminiOnce = false


    const collectCurrentParams = function(){
        const params = new URLSearchParams()
        document.querySelectorAll('input').forEach((input) => {
            if (input.type === 'file') {
                // ignore file inputs
            } else if (input.type === 'checkbox') {
                params.set(input.id, input.checked)
            } else {
                params.set(input.id, input.value)
            }
        })
        return params
    }

    const saveToURL = function () {
        const urlParams = collectCurrentParams()
        btnDeeplink.href = '?' + urlParams.toString()
        // window.location.search = urlParams.toString()
    }

    const buildDownloadFilename = function(){
        // Short, file-safe summary using only core fields with abbreviated keys
        const shortKeyMap = {
            inputBackgroundURL: 'bg',
            inputPose: 'p',
            inputSecondURL: 's2',
            inputThirdURL: 's3',
            inputText1: 't1',
            inputText2: 't2',
            inputCanvasColor: 'cc'
        }
        const ids = Object.keys(shortKeyMap)
        const getVal = id => {
            const el = eId(id)
            return el ? String(el.value || '') : ''
        }
        const shortenVal = function(id, v){
            if (!v) return ''
            // URLs → last segment or short prompt token
            if (/^https?:\/\//i.test(v)) {
                try {
                    const u = new URL(v.indexOf('http')===0? v : v.replace(/^.*url=/,'').replace(/%2F/gi,'/'))
                    const seg = (u.pathname.split('/').pop() || '').split('?')[0]
                    return (seg || 'url').slice(0, 20)
                } catch(e){ return 'url' }
            }
            if (/^gemini:\/\//i.test(v)) {
                return ('gm_' + v.replace(/^gemini:\/\//i,'')).replace(/\W+/g,'_').slice(0, 20)
            }
            if (id === 'inputCanvasColor') {
                return v.replace('#','')
            }
            // text/numbers
            return v.replace(/\s+/g,'_').replace(/\W+/g,'_').slice(0, 20)
        }
        const parts = []
        ids.forEach(function(id){
            const val = getVal(id)
            if (!val) return
            const sk = shortKeyMap[id]
            const sv = shortenVal(id, val)
            if (sv) parts.push(sk + '-' + sv)
        })
        let base = parts.join('__') || 'img'
        base = base.replace(/_+/g,'_').replace(/^_+|_+$/g,'')
        if (base.length > 80) base = base.slice(0,80)
        return base + '.jpg'
    }

    const loadFromURL = function () {
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);

        document.querySelectorAll('input').forEach((input) => {
            if (urlParams.get(input.id) !== null) {
                if (input.type === 'file') {

                } else if (input.type === 'checkbox') {
                    input.checked = urlParams.get(input.id) === 'true' ? true : false
                } else {
                    input.value = urlParams.get(input.id)
                }

            }

        })


    }

	const loadImage = function (src) {
		return new Promise((resolve, reject) => {
			const img = new Image();
			img.onload = () => resolve(img);
			img.onerror = reject;
			img.src = src;
		})
	}


	const loadImagesAndRender = function () {

		// Build entries with ids to maintain mapping
		var entries = [
			{ id: 'logo', url: 'img/logo.svg' },
			{ id: inputPose.id, url: (inputPoseURL.value && !suspendPoseGeminiOnce && inputPoseURL.value.indexOf('blob22:') !== 0) ? inputPoseURL.value : ('img/poses/' + inputPose.value + '.png') }
		]

		if (inputBackgroundURL.value && inputBackgroundURL.value.indexOf('blob22:') !== 0) {
			entries.push({ id: inputBackgroundURL.id, url: inputBackgroundURL.value })
		}
		if (inputSecondURL.value && inputSecondURL.value.indexOf('blob22:') !== 0) {
			entries.push({ id: inputSecondURL.id, url: inputSecondURL.value })
		}
		if (inputThirdURL.value && inputThirdURL.value.indexOf('blob22:') !== 0) {
			entries.push({ id: inputThirdURL.id, url: inputThirdURL.value })
		}

		// Map URLs
		const mapped = entries.map(e => {
			var finalUrl = e.url
			if (finalUrl.indexOf('gemini://') === 0) {
				if (e.id === inputPose.id) {
					const poseImageUrl = 'img/poses/' + inputPose.value + '.png'
					finalUrl = './image.php?url=' + encodeURIComponent(finalUrl) + '&pose=' + encodeURIComponent(poseImageUrl)
				} else {
					finalUrl = './image.php?url=' + encodeURIComponent(finalUrl)
				}
			} else if (finalUrl.indexOf('unsplash.com') > -1 && finalUrl.indexOf('proxyoff') == -1) {
				finalUrl = './image.php?url=' + encodeURIComponent(finalUrl)
			}
			return { id: e.id, src: finalUrl }
		})

		return Promise.all(mapped.map(m => loadImage(m.src))).then(images => {
			for (var i = 0; i < mapped.length; i++) {
				const id = mapped[i].id
				const im = images[i]
				if (id === 'logo') { imgLogo = im; continue }
				if (id === inputPose.id) { imgPose = im; continue }
				if (id === inputBackgroundURL.id) { imgBackground = im; continue }
				if (id === inputSecondURL.id) { imgSecond = im; continue }
				if (id === inputThirdURL.id) { imgThird = im; continue }
			}
            updatePoseMask()
            updateSecondMask()
            updateThirdMask()
			render()
		})
	}


    const drawBackground = function () {
        // background
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = (typeof inputCanvasColor !== 'undefined' && inputCanvasColor.value) ? inputCanvasColor.value : colorBackground
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore()
    }

    const drawText1 = function () {
        // text line 1
        ctx.save();
        ctx.font = "64pt Impact"
        ctx.strokeStyle = 'black'
        ctx.lineWidth = 4
        ctx.textAlign = "end"
        ctx.textBaseline = "bottom"
        ctx.fillStyle = colorBrand //<======= here
        // Disable glow/shadow for solid style
        ctx.shadowColor = "transparent";
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.shadowBlur = 0;

        drawTextT(inputText1.value, inputText1.id, canvas.width - 50, canvas.height - 50)
        ctx.restore()
    }

    const drawText2 = function () {
        // text line 1
        ctx.save();
        ctx.font = "64pt Impact"
        ctx.strokeStyle = 'black'
        ctx.lineWidth = 4
        ctx.textAlign = "start"
        ctx.textBaseline = "bottom"
        ctx.fillStyle = 'black' //<======= here
        // Disable glow/shadow for solid style
        ctx.shadowColor = "transparent";
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        ctx.shadowBlur = 0;

        drawTextT(inputText2.value, inputText2.id, 50, canvas.height - 50)

        ctx.restore()
    }


    const drawBottomBorder = function () {
        // bottom border

        ctx.save();
        ctx.fillStyle = colorBrand
        ctx.fillRect(0, canvas.height - 20, canvas.width, 20)
        ctx.restore()
    }




    const drawTextT = function (text, tid, x, y) {
        const w = ctx.measureText(text).width
        const m = ctx.measureText(text)
        const h = (m.actualBoundingBoxAscent || 40) + (m.actualBoundingBoxDescent || 10)
        ctx.save();
        ctx.translate(x, y)
        ctx.translate(eId(`tf_${tid}_x`).value, eId(`tf_${tid}_y`).value)
        ctx.translate(w / 2, h / 2)
        ctx.rotate(eId(`tf_${tid}_r`).value * Math.PI / 180)
        ctx.scale(eId(`tf_${tid}_s`).value * 0.01, eId(`tf_${tid}_s`).value * 0.01)
        ctx.scale(eId(`tf_${tid}_h`).checked ? -1 : 1, eId(`tf_${tid}_v`).checked ? -1 : 1)
        ctx.translate(-w / 2, -h / 2)
        // Compute local offset by current align/baseline
        let offX = 0, offY = 0
        const ta = String(ctx.textAlign || '').toLowerCase()
        if (ta === 'center') offX = -w / 2
        else if (ta === 'end' || ta === 'right') offX = -w
        else offX = 0
        const tb = String(ctx.textBaseline || '').toLowerCase()
        if (tb === 'bottom' || tb === 'ideographic') offY = -h
        else if (tb === 'middle') offY = -h / 2
        else offY = 0 // top/hanging/alphabetic approximated as top
        // Draw solid background for Text1 (black) and Text2 (brand yellow) with border
        const bgColor = (tid === inputText1.id) ? 'black' : (tid === inputText2.id ? colorBrand : '')
        const manualFontOffsetY = 11;
        const padX = 12, padY = 12
        if (bgColor) {
            const prevFill = ctx.fillStyle
            const prevStroke = ctx.strokeStyle
            const prevLineWidth = ctx.lineWidth
            ctx.fillStyle = bgColor
            ctx.fillRect(offX-padX, offY-padY, w+padX*2, h+padY*2)
            ctx.fillStyle = prevFill
            ctx.strokeStyle = prevStroke
            ctx.lineWidth = prevLineWidth
        }
        ctx.fillText(text, 0, manualFontOffsetY)
        if (typeof selectedId !== 'undefined' && selectedId === tid) {
            ctx.save()
            ctx.strokeStyle = 'rgba(255,192,0,0.9)'
            ctx.lineWidth = 2
            ctx.setLineDash([8,4])
            ctx.strokeRect(offX-padX, offY-padY, w+padX*2, h+padY*2)
            ctx.restore()
        }
        ctx.restore()
    }

    const drawImageT = function (img, tid, x, y, w, h, options) {
        ctx.save();
        ctx.translate(x, y)
        ctx.translate(eId(`tf_${tid}_x`).value, eId(`tf_${tid}_y`).value)
        if (!options?.tl) ctx.translate(w / 2, h / 2)
        ctx.rotate(eId(`tf_${tid}_r`).value * Math.PI / 180)
        ctx.scale(eId(`tf_${tid}_s`).value * 0.01, eId(`tf_${tid}_s`).value * 0.01)
        ctx.scale(eId(`tf_${tid}_h`).checked ? -1 : 1, eId(`tf_${tid}_v`).checked ? -1 : 1)
        if (!options?.tl) ctx.translate(-w / 2, -h / 2)
        ctx.drawImage(img, 0, 0, w, h);
        if (typeof selectedId !== 'undefined' && selectedId === tid) {
            ctx.save()
            ctx.strokeStyle = 'rgba(255,192,0,0.9)'
            ctx.lineWidth = 2
            ctx.setLineDash([8,4])
            ctx.strokeRect(0, 0, w, h)
            ctx.restore()
        }
        ctx.restore()
    }



    const drawImageLogo = function () {
        ctx.save();
        ctx.fillStyle = colorLogo
        ctx.fillRect(canvas.width - imgLogo.width - paddingBackgroundLogoPixel * 2, 0, imgLogo.width + paddingBackgroundLogoPixel * 2, imgLogo.height + paddingBackgroundLogoPixel * 2)
        ctx.drawImage(imgLogo, canvas.width - imgLogo.width - paddingBackgroundLogoPixel, paddingBackgroundLogoPixel);
        ctx.restore()
    }

    const drawImagePose = function () {
        const source = (typeof chkPoseMask !== 'undefined' && chkPoseMask.checked && poseProcessedCanvas) ? poseProcessedCanvas : imgPose
        const w = imgPoseWidth
        const h = w * source.height / source.width
        drawImageT(source, inputPose.id, canvas.width * 0.1, canvas.height * 0.3, w, h)
    }

    const drawImageBackground = function () {
        const w = Math.min(canvas.width, imgBackground.width)
        drawImageT(imgBackground, inputBackgroundURL.id, 0, 0, w, w * imgBackground.height / imgBackground.width);
    }

    const drawImageSecond = function () {
        const source = (typeof chkSecondMask !== 'undefined' && chkSecondMask.checked && secondProcessedCanvas) ? secondProcessedCanvas : imgSecond
        drawImageT(source, inputSecondURL.id, 0, 0, imgSecond.width, imgSecond.height, { tl: true });
    }


    const drawImageThird = function () {
        const source = (typeof chkThirdMask !== 'undefined' && chkThirdMask.checked && thirdProcessedCanvas) ? thirdProcessedCanvas : imgThird
        drawImageT(source, inputThirdURL.id, 0, 0, imgThird.width, imgThird.height, { tl: false });
    }


    const render = function () {
        drawBackground()
        if (imgBackground) { drawImageBackground() }
        if (imgThird) { drawImageThird() }
        if (imgPose) { drawImagePose() }
        if (imgSecond) { drawImageSecond() }
        drawImageLogo()
        drawText1()
        drawText2()
        drawBottomBorder()
        saveToURL()
    }


    // 

    function diff(x, y) {

        if (Math.sign(x) === Math.sign(y)) {

            return Math.abs(x - y);

        } else {

            return Math.abs(x) + Math.abs(y);

        };

    };

    function randn_bm() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random(); //Converting [0,1) to (0,1)
        while (v === 0) v = Math.random();
        let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        num = num / 10.0 + 0.5; // Translate to 0 -> 1
        if (num > 1 || num < 0) return randn_bm() // resample between 0 and 1
        return num
    }

    const randomizeInputByMinMax = function (el, onlyInteger) {
        const max = el.getAttribute('data-random-max') || el.max
        const min = el.getAttribute('data-random-min') || el.min
        const result = parseFloat(el.min) + randn_bm() * diff(max, min)
        if (onlyInteger) {
            el.value = parseInt(result)
        } else {
            el.value = result
        }

    }
    const randomizeTransform = function (id) {
        randomizeInputByMinMax(eId('tf_' + id + '_x'))
        randomizeInputByMinMax(eId('tf_' + id + '_y'))
        randomizeInputByMinMax(eId('tf_' + id + '_r'))
        randomizeInputByMinMax(eId('tf_' + id + '_s'))
        eId('tf_' + id + '_h').checked = randn_bm() > 0.5 ? 1 : 0
        eId('tf_' + id + '_v').checked = randn_bm() > 0.5 ? 1 : 0
        if (eId('tfn_' + id + '_x')) { eId('tfn_' + id + '_x').value = eId('tf_' + id + '_x').value }
        if (eId('tfn_' + id + '_y')) { eId('tfn_' + id + '_y').value = eId('tf_' + id + '_y').value }
        if (eId('tfn_' + id + '_r')) { eId('tfn_' + id + '_r').value = eId('tf_' + id + '_r').value }
        if (eId('tfn_' + id + '_s')) { eId('tfn_' + id + '_s').value = eId('tf_' + id + '_s').value }
        render()
    }

    const resetInput = el => el.value = el.defaultValue
    const resetTransform = function (id) {
        resetInput(eId('tf_' + id + '_x'))
        resetInput(eId('tf_' + id + '_y'))
        resetInput(eId('tf_' + id + '_r'))
        resetInput(eId('tf_' + id + '_s'))
        eId('tf_' + id + '_h').checked = 0
        eId('tf_' + id + '_v').checked = 0
        if (eId('tfn_' + id + '_x')) { eId('tfn_' + id + '_x').value = eId('tf_' + id + '_x').value }
        if (eId('tfn_' + id + '_y')) { eId('tfn_' + id + '_y').value = eId('tf_' + id + '_y').value }
        if (eId('tfn_' + id + '_r')) { eId('tfn_' + id + '_r').value = eId('tf_' + id + '_r').value }
        if (eId('tfn_' + id + '_s')) { eId('tfn_' + id + '_s').value = eId('tf_' + id + '_s').value }
        render()
    }

    const addTransformMenu = function (id, menuElement) {
        menuElement.innerHTML = `<br>x/y/s/r/m: 
<input id="tf_${id}_x" type="range" min="-1960" max="2280" value="0" title="x" oninput="eId('tfn_${id}_x').value=this.value; render()"/>
<input class=\"ui-level-2\" id="tfn_${id}_x" type="number" min="-1960" max="2280" value="0" step="1" title="x" oninput="eId('tf_${id}_x').value=this.value; render()"/>
<input id="tf_${id}_y" type="range" min="-2280" max="1640" value="0" title="y" oninput="eId('tfn_${id}_y').value=this.value; render()"/>
<input class=\"ui-level-2\" id="tfn_${id}_y" type="number" min="-2280" max="1640" value="0" step="1" title="y" oninput="eId('tf_${id}_y').value=this.value; render()"/>
<input id="tf_${id}_s" type="range" min="-1000" max="1000" value="100" data-random-min="50" data-random-max="250" title="scale" oninput="eId('tfn_${id}_s').value=this.value; render()"/>
<input class=\"ui-level-2\" id="tfn_${id}_s" type="number" min="-1000" max="1000" value="100" step="1" title="scale" oninput="eId('tf_${id}_s').value=this.value; render()"/>
<input id="tf_${id}_r" type="range" min="-360" max="360" value="0" title="rotation" oninput="eId('tfn_${id}_r').value=this.value; render()"/>
<input class=\"ui-level-2\" id="tfn_${id}_r" type="number" min="-360" max="360" value="0" step="1" title="rotation" oninput="eId('tf_${id}_r').value=this.value; render()"/>
<input title="mirror horizontal" type="checkbox" id="tf_${id}_h"/>
<input title="mirror vertical" type="checkbox" id="tf_${id}_v"/>
<button title="chaos" onclick="randomizeTransform('${id}')">c</button>
<button title="reset" onclick="resetTransform('${id}')">r</button>`
    }

    addTransformMenu(inputPose.id, spanPosesPosition)
    addTransformMenu(inputBackgroundURL.id, spanBackgroundPosition)
    addTransformMenu(inputText1.id, spanText1Position)
    addTransformMenu(inputText2.id, spanText2Position)
    addTransformMenu(inputSecondURL.id, spanSecondPosition)
    addTransformMenu(inputThirdURL.id, spanThirdPosition)

    const syncTransformNumbersFor = function(id){
        const keys = ['x','y','s','r']
        keys.forEach(function(k){
            const r = eId('tf_' + id + '_' + k)
            const n = eId('tfn_' + id + '_' + k)
            if (r && n) { n.value = r.value }
        })
    }
    const syncAllTransformNumbers = function(){
        [inputPose.id, inputBackgroundURL.id, inputText1.id, inputText2.id, inputSecondURL.id, inputThirdURL.id].forEach(function(i){ syncTransformNumbersFor(i) })
    }
    syncAllTransformNumbers()

    const escapeHtml = function (s) {
        return String(s || '').replace(/[&<>"']/g, function (c) {
            return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[c];
        })
    }

    const renderPoseList = function(){
        if (!Array.isArray(normalPosesData)) { normalPosesData = [] }
        if (typeof poseListItems !== 'undefined') {
            poseListItems.innerHTML = normalPosesData.map(function(p){
                return "<img onclick=\"inputPose.value=" + p.index + ";inputPoseURL.value='';inputPoseKeyColor.dataset.sampled='';loadImagesAndRender()\" src=\"" + p.thumb + "\">"
            }).join("")
        }
        if (typeof inputPose !== 'undefined') {
            inputPose.max = Math.max(0, normalPosesData.length - 1)
            if (parseInt(inputPose.value, 10) > parseInt(inputPose.max, 10)) {
                inputPose.value = inputPose.max
            }
        }
    }

    const renderGeneratedPoseList = function(){
        if (!Array.isArray(generatedPosesData)) { generatedPosesData = [] }
        var list = showAllGeneratedPoses ? generatedPosesData : generatedPosesData.slice(0, THUMBS_PAGE_SIZE)
        if (typeof generatedPoseListItems !== 'undefined') {
            generatedPoseListItems.innerHTML = list.map(function(g){
                return "<span class=\"assetItem\"><img title=\"" + escapeHtml(g.prompt) + "\" onclick=\"inputPoseURL.value='" + g.url + "';inputPoseKeyColor.dataset.sampled='';loadImagesAndRender()\" src=\"" + g.thumb + "\"><button class=\"deleteBtn\" title=\"Delete pose\" onclick=\"deleteGeneratedAsset(event,'pose','" + g.url + "')\">×</button></span>"
            }).join("")
        }
        if (typeof btnShowAllGeneratedPoses !== 'undefined') {
            btnShowAllGeneratedPoses.style.display = (generatedPosesData.length > THUMBS_PAGE_SIZE && !showAllGeneratedPoses) ? 'inline-flex' : 'none'
        }
    }

    const renderGeneratedBackgroundList = function(){
        if (!Array.isArray(generatedBackgroundsData)) { generatedBackgroundsData = [] }
        var list = showAllGeneratedBackgrounds ? generatedBackgroundsData : generatedBackgroundsData.slice(0, THUMBS_PAGE_SIZE)
        if (typeof generatedBackgroundListItems !== 'undefined') {
            generatedBackgroundListItems.innerHTML = list.map(function(g){
                return "<span class=\"assetItem\"><img title=\"" + escapeHtml(g.prompt) + "\" onclick=\"inputBackgroundURL.value='" + g.url + "';loadImagesAndRender()\" src=\"" + g.thumb + "\"><button class=\"deleteBtn\" title=\"Delete background\" onclick=\"deleteGeneratedAsset(event,'background','" + g.url + "')\">×</button></span>"
            }).join("")
        }
        if (typeof btnShowAllGeneratedBackgrounds !== 'undefined') {
            btnShowAllGeneratedBackgrounds.style.display = (generatedBackgroundsData.length > THUMBS_PAGE_SIZE && !showAllGeneratedBackgrounds) ? 'inline-flex' : 'none'
        }
    }

    const renderResultsList = function(){
        if (!Array.isArray(resultsData)) { resultsData = [] }
        var list = showAllResults ? resultsData : resultsData.slice(0, THUMBS_PAGE_SIZE)
        if (typeof resultsListItems !== 'undefined') {
            resultsListItems.innerHTML = list.map(function(r){
                var dl = '<a class="btn" href="' + r.url + '" download>Download</a>'
                var rs = r.json ? '<button class="btn" onclick="restoreResultSettings(\'' + r.json + '\')">Restore</button>' : ''
                return '<span class="assetItem"><a href="' + r.url + '" target="_blank"><img src="' + r.thumb + '"></a>' + dl + ' ' + rs + '</span>'
            }).join("")
        }
        if (typeof btnShowAllResults !== 'undefined') {
            btnShowAllResults.style.display = (resultsData.length > THUMBS_PAGE_SIZE && !showAllResults) ? 'inline-flex' : 'none'
        }
    }

    const populateAssetLists = function () {
        fetch('./assets.php')
            .then(r => r.json())
            .then(data => {
                if (Array.isArray(data.normalPoses)) {
                    normalPosesData = data.normalPoses
                    renderPoseList()
                }
                if (Array.isArray(data.generatedPoses)) {
                    generatedPosesData = data.generatedPoses
                    renderGeneratedPoseList()
                }
                if (Array.isArray(data.generatedBackgrounds)) {
                    generatedBackgroundsData = data.generatedBackgrounds
                    renderGeneratedBackgroundList()
                }
                if (Array.isArray(data.results)) {
                    resultsData = data.results
                    renderResultsList()
                }
            })
            .catch(() => { /* ignore */ })
    }

    // Show-all buttons
    if (typeof btnShowAllGeneratedPoses !== 'undefined') {
        btnShowAllGeneratedPoses.addEventListener('click', function(){
            showAllGeneratedPoses = true
            renderGeneratedPoseList()
        })
    }
    if (typeof btnShowAllGeneratedBackgrounds !== 'undefined') {
        btnShowAllGeneratedBackgrounds.addEventListener('click', function(){
            showAllGeneratedBackgrounds = true
            renderGeneratedBackgroundList()
        })
    }
    if (typeof btnShowAllResults !== 'undefined') {
        btnShowAllResults.addEventListener('click', function(){
            showAllResults = true
            renderResultsList()
        })
    }
    



    // Toggle visibility of prompt inputs for Background and SecondImage
    btnPromptBackground.addEventListener('click', function () {
        spanPromptBackground.style.display = (spanPromptBackground.style.display === 'none' || !spanPromptBackground.style.display) ? 'inline' : 'none'
    })
    btnPromptSecond.addEventListener('click', function () {
        spanPromptSecond.style.display = (spanPromptSecond.style.display === 'none' || !spanPromptSecond.style.display) ? 'inline' : 'none'
    })
    btnPromptThird.addEventListener('click', function () {
        spanPromptThird.style.display = (spanPromptThird.style.display === 'none' || !spanPromptThird.style.display) ? 'inline' : 'none'
    })
	// Toggle visibility for Pose prompt
	btnPromptPose.addEventListener('click', function () {
		spanPromptPose.style.display = (spanPromptPose.style.display === 'none' || !spanPromptPose.style.display) ? 'inline' : 'none'
	})

    // Enter in prompt fields triggers associated Generate button
    inputPromptBackground.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') { e.preventDefault(); btnGenerateBackground.click(); }
    })
    inputPromptSecond.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') { e.preventDefault(); btnGenerateSecond.click(); }
    })
    inputPromptThird.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') { e.preventDefault(); btnGenerateThird.click(); }
    })
	// Enter in Pose prompt triggers Generate
	inputPromptPose.addEventListener('keydown', function (e) {
		if (e.key === 'Enter') { e.preventDefault(); btnGeneratePose.click(); }
	})

    // Generate via Gemini for Background (with optional reference images)
    btnGenerateBackground.addEventListener('click', function () {
        const prompt = inputPromptBackground.value.trim()
        if (!prompt) { return }
        const previousText = this.textContent
        this.disabled = true
        this.textContent = '⏳'

        // Build image.php request with refs: Background (if checkbox), then Pose, Second, Third
        const wasBg = inputBackgroundURL.value
        const isBlob = s => (String(s || '').indexOf('blob:') === 0 || String(s || '').indexOf('blob22:') === 0)
        const toProxyUrl = s => {
            if (!s) return ''
            if (s.indexOf('./image.php') === 0 || s.indexOf('image.php') === 0) return s
            if (s.indexOf('http://') === 0 || s.indexOf('https://') === 0) return './image.php?url=' + encodeURIComponent(s)
            if (s.indexOf('gemini://') === 0) return './image.php?url=' + encodeURIComponent(s)
            // local file path (e.g., img/poses/..)
            return s
        }

        let finalUrl = './image.php?url=' + encodeURIComponent('gemini://' + prompt)

        // Background ref (only when checkbox is checked); still proceed if not present
        if (typeof chkBgBackground !== 'undefined' && chkBgBackground.checked) {
            if (wasBg && !isBlob(wasBg)) {
                const bgRef = toProxyUrl(wasBg)
                if (bgRef) { finalUrl += '&ref_background=' + encodeURIComponent(bgRef) }
            }
        }

        // Pose ref (optional)
        if (typeof chkBgPose !== 'undefined' && chkBgPose.checked) {
            let poseRef = ''
            if (inputPoseURL.value && String(inputPoseURL.value).indexOf('blob:') !== 0) {
                poseRef = toProxyUrl(inputPoseURL.value)
            } else {
                poseRef = 'img/poses/' + inputPose.value + '.png'
            }
            if (poseRef) { finalUrl += '&ref_pose=' + encodeURIComponent(poseRef) }
        }

        // Second ref (optional)
        if (typeof chkBgSecond !== 'undefined' && chkBgSecond.checked) {
            const s = inputSecondURL.value
            if (s && !isBlob(s)) {
                const secRef = toProxyUrl(s)
                if (secRef) { finalUrl += '&ref_second=' + encodeURIComponent(secRef) }
            }
        }

        // Third ref (optional)
        if (typeof chkBgThird !== 'undefined' && chkBgThird.checked) {
            const t = inputThirdURL.value
            if (t && !isBlob(t)) {
                const thRef = toProxyUrl(t)
                if (thRef) { finalUrl += '&ref_third=' + encodeURIComponent(thRef) }
            }
        }

        // Set and render
        inputBackgroundURL.value = finalUrl
        suspendPoseGeminiOnce = true
        loadImagesAndRender()
            .then(() => {
                suspendPoseGeminiOnce = false
                this.disabled = false
                this.textContent = previousText
            })
            .catch(() => {
                suspendPoseGeminiOnce = false
                this.disabled = false
                this.textContent = previousText
            })
    })

    // Generate via Gemini for SecondImage
	btnGenerateSecond.addEventListener('click', function () {
		const prompt = inputPromptSecond.value.trim()
		if (!prompt) { return }
		const previousText = this.textContent
		this.disabled = true
		this.textContent = '⏳'
        inputSecondURL.value = 'gemini://' + prompt
		suspendPoseGeminiOnce = true
		loadImagesAndRender()
			.then(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
			.catch(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
	})

    // Generate via Gemini for ThirdImage
	btnGenerateThird.addEventListener('click', function () {
		const prompt = inputPromptThird.value.trim()
		if (!prompt) { return }
		const previousText = this.textContent
		this.disabled = true
		this.textContent = '⏳'
        inputThirdURL.value = 'gemini://' + prompt
		suspendPoseGeminiOnce = true
		loadImagesAndRender()
			.then(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
			.catch(() => {
				suspendPoseGeminiOnce = false
				this.disabled = false
				this.textContent = previousText
			})
	})

    // --- Pose masking utilities ---
    const hexToRgb = function (hex) {
        try {
            const h = hex.replace('#','')
            const n = parseInt(h, 16)
            if (h.length === 6) {
                return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 }
            }
        } catch(e) { }
        return { r: 255, g: 0, b: 255 }
    }

    const samplePoseKeyFromBorders = function (img, sample) {
        const w = img.width, h = img.height
        const s = Math.max(1, Math.min(sample, Math.min(w, h)))
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const c = off.getContext('2d')
        c.drawImage(img, 0, 0)
        const get = (x,y)=>c.getImageData(x,y,1,1).data
        let sumR=0,sumG=0,sumB=0,cnt=0
        for (let x=0;x<w;x++) {
            for (let y=0;y<s;y++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
            for (let y=h-s;y<h;y++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
        }
        for (let y=0;y<h;y++) {
            for (let x=0;x<s;x++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
            for (let x=w-s;x<w;x++){ const d=get(x,y); sumR+=d[0]; sumG+=d[1]; sumB+=d[2]; cnt++; }
        }
        return { r: Math.round(sumR/cnt), g: Math.round(sumG/cnt), b: Math.round(sumB/cnt) }
    }

    const updatePoseMask = function () {
        poseProcessedCanvas = null
        if (!imgPose) return
        if (typeof chkPoseMask === 'undefined' || !chkPoseMask.checked) return
        const tol = parseInt(inputPoseTolerance.value || '0', 10)
        const soft = parseInt(inputPoseSoftness.value || '0', 10)
        let rgb = hexToRgb(inputPoseKeyColor.value || '#ff66cc')
        // If color is default and we have an image, auto-sample on first run
        if (!inputPoseKeyColor.dataset.sampled) {
            const sampled = samplePoseKeyFromBorders(imgPose, 5)
            rgb = sampled
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputPoseKeyColor.value = hex
            inputPoseKeyColor.dataset.sampled = '1'
        }

        const w = imgPose.width, h = imgPose.height
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const ctx2 = off.getContext('2d')
        ctx2.drawImage(imgPose, 0, 0)
        const imgData = ctx2.getImageData(0, 0, w, h)
        const data = imgData.data
        const thr = Math.max(0, tol)
        const sf = Math.max(0, soft)
        const softLo = Math.max(0, thr - sf)
        const softHi = thr + sf
        for (let i=0;i<data.length;i+=4){
            const r=data[i], g=data[i+1], b=data[i+2]
            const dr=r-rgb.r, dg=g-rgb.g, db=b-rgb.b
            const d=Math.sqrt(dr*dr+dg*dg+db*db)
            let alphaFactor = 1
            if (d <= softLo) {
                alphaFactor = 0
            } else if (d < softHi) {
                alphaFactor = (d - softLo) / (softHi - softLo)
            }
            data[i+3] = Math.round(data[i+3] * alphaFactor)
        }
        ctx2.putImageData(imgData, 0, 0)
        poseProcessedCanvas = off
    }

    const updateSecondMask = function () {
        secondProcessedCanvas = null
        if (!imgSecond) return
        if (typeof chkSecondMask === 'undefined' || !chkSecondMask.checked) return
        const tol = parseInt(inputSecondTolerance.value || '0', 10)
        const soft = parseInt(inputSecondSoftness.value || '0', 10)
        let rgb = hexToRgb(inputSecondKeyColor.value || '#ff66cc')
        if (!inputSecondKeyColor.dataset.sampled) {
            const sampled = samplePoseKeyFromBorders(imgSecond, 5)
            rgb = sampled
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputSecondKeyColor.value = hex
            inputSecondKeyColor.dataset.sampled = '1'
        }
        const w = imgSecond.width, h = imgSecond.height
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const ctx2 = off.getContext('2d')
        ctx2.drawImage(imgSecond, 0, 0)
        const imgData = ctx2.getImageData(0, 0, w, h)
        const data = imgData.data
        const thr = Math.max(0, tol)
        const sf = Math.max(0, soft)
        const softLo = Math.max(0, thr - sf)
        const softHi = thr + sf
        for (let i=0;i<data.length;i+=4){
            const r=data[i], g=data[i+1], b=data[i+2]
            const dr=r-rgb.r, dg=g-rgb.g, db=b-rgb.b
            const d=Math.sqrt(dr*dr+dg*dg+db*db)
            let alphaFactor = 1
            if (d <= softLo) {
                alphaFactor = 0
            } else if (d < softHi) {
                alphaFactor = (d - softLo) / (softHi - softLo)
            }
            data[i+3] = Math.round(data[i+3] * alphaFactor)
        }
        ctx2.putImageData(imgData, 0, 0)
        secondProcessedCanvas = off
    }

    const updateThirdMask = function () {
        thirdProcessedCanvas = null
        if (!imgThird) return
        if (typeof chkThirdMask === 'undefined' || !chkThirdMask.checked) return
        const tol = parseInt(inputThirdTolerance.value || '0', 10)
        const soft = parseInt(inputThirdSoftness.value || '0', 10)
        let rgb = hexToRgb(inputThirdKeyColor.value || '#ff66cc')
        if (!inputThirdKeyColor.dataset.sampled) {
            const sampled = samplePoseKeyFromBorders(imgThird, 5)
            rgb = sampled
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputThirdKeyColor.value = hex
            inputThirdKeyColor.dataset.sampled = '1'
        }
        const w = imgThird.width, h = imgThird.height
        const off = document.createElement('canvas')
        off.width = w; off.height = h
        const ctx2 = off.getContext('2d')
        ctx2.drawImage(imgThird, 0, 0)
        const imgData = ctx2.getImageData(0, 0, w, h)
        const data = imgData.data
        const thr = Math.max(0, tol)
        const sf = Math.max(0, soft)
        const softLo = Math.max(0, thr - sf)
        const softHi = thr + sf
        for (let i=0;i<data.length;i+=4){
            const r=data[i], g=data[i+1], b=data[i+2]
            const dr=r-rgb.r, dg=g-rgb.g, db=b-rgb.b
            const d=Math.sqrt(dr*dr+dg*dg+db*db)
            let alphaFactor = 1
            if (d <= softLo) {
                alphaFactor = 0
            } else if (d < softHi) {
                alphaFactor = (d - softLo) / (softHi - softLo)
            }
            data[i+3] = Math.round(data[i+3] * alphaFactor)
        }
        ctx2.putImageData(imgData, 0, 0)
        thirdProcessedCanvas = off
    }

    // UI events for pose masking
    if (typeof chkPoseMask !== 'undefined') {
        chkPoseMask.addEventListener('change', function(){ updatePoseMask(); render(); })
    }
    if (typeof inputPoseKeyColor !== 'undefined') {
        inputPoseKeyColor.addEventListener('input', function(){ inputPoseKeyColor.dataset.sampled='1'; updatePoseMask(); render(); })
    }
    if (typeof inputPoseTolerance !== 'undefined') {
        inputPoseTolerance.addEventListener('input', function(){ updatePoseMask(); render(); })
    }
    if (typeof inputPoseSoftness !== 'undefined') {
        inputPoseSoftness.addEventListener('input', function(){ updatePoseMask(); render(); })
    }
    if (typeof btnPoseSample !== 'undefined') {
        btnPoseSample.addEventListener('click', function(){
            if (!imgPose) return
            const sampled = samplePoseKeyFromBorders(imgPose, 5)
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputPoseKeyColor.value = hex
            inputPoseKeyColor.dataset.sampled = '1'
            updatePoseMask(); render();
        })
    }

    // UI events for second image masking
    if (typeof chkSecondMask !== 'undefined') {
        chkSecondMask.addEventListener('change', function(){ updateSecondMask(); render(); })
    }
    if (typeof inputSecondKeyColor !== 'undefined') {
        inputSecondKeyColor.addEventListener('input', function(){ inputSecondKeyColor.dataset.sampled='1'; updateSecondMask(); render(); })
    }
    if (typeof inputSecondTolerance !== 'undefined') {
        inputSecondTolerance.addEventListener('input', function(){ updateSecondMask(); render(); })
    }
    if (typeof inputSecondSoftness !== 'undefined') {
        inputSecondSoftness.addEventListener('input', function(){ updateSecondMask(); render(); })
    }
    if (typeof btnSecondSample !== 'undefined') {
        btnSecondSample.addEventListener('click', function(){
            if (!imgSecond) return
            const sampled = samplePoseKeyFromBorders(imgSecond, 5)
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputSecondKeyColor.value = hex
            inputSecondKeyColor.dataset.sampled = '1'
            updateSecondMask(); render();
        })
    }

    // UI events for third image masking
    if (typeof chkThirdMask !== 'undefined') {
        chkThirdMask.addEventListener('change', function(){ updateThirdMask(); render(); })
    }
    if (typeof inputThirdKeyColor !== 'undefined') {
        inputThirdKeyColor.addEventListener('input', function(){ inputThirdKeyColor.dataset.sampled='1'; updateThirdMask(); render(); })
    }
    if (typeof inputThirdTolerance !== 'undefined') {
        inputThirdTolerance.addEventListener('input', function(){ updateThirdMask(); render(); })
    }
    if (typeof inputThirdSoftness !== 'undefined') {
        inputThirdSoftness.addEventListener('input', function(){ updateThirdMask(); render(); })
    }
    if (typeof btnThirdSample !== 'undefined') {
        btnThirdSample.addEventListener('click', function(){
            if (!imgThird) return
            const sampled = samplePoseKeyFromBorders(imgThird, 5)
            const hex = '#' + [sampled.r, sampled.g, sampled.b].map(x=>x.toString(16).padStart(2,'0')).join('')
            inputThirdKeyColor.value = hex
            inputThirdKeyColor.dataset.sampled = '1'
            updateThirdMask(); render();
        })
    }

	// Generate via Gemini for Pose (passes pose index to backend)
	btnGeneratePose.addEventListener('click', function () {
		const prompt = inputPromptPose.value.trim()
		if (!prompt) { return }
		const previousText = this.textContent
		this.disabled = true
		this.textContent = '⏳'
		inputPoseURL.value = 'gemini://' + prompt
		loadImagesAndRender()
			.then(() => {
				this.disabled = false
				this.textContent = previousText
			})
			.catch(() => {
				this.disabled = false
				this.textContent = previousText
			})
	})

	// Clicking the pose input should revert to normal pose selection
	if (typeof inputPose !== 'undefined') {
		inputPose.addEventListener('click', function(){
			if (inputPoseURL.value) {
				inputPoseURL.value = ''
				if (typeof inputPoseKeyColor !== 'undefined') { inputPoseKeyColor.dataset.sampled = '' }
				loadImagesAndRender()
			}
		})
	}


    document.querySelectorAll('[data-image-target]').forEach((input) => input.onchange = function (e) {
        const inp = eId(e.target.getAttribute('data-image-target'))
        inp.value = URL.createObjectURL(this.files[0]);
        loadImagesAndRender()
    })

    loadFromURL()
    syncAllTransformNumbers()
    loadImagesAndRender()
    populateAssetLists()

    tf_inputSecondURL_s.value = 27
    if (typeof syncTransformNumbersFor === 'function') { syncTransformNumbersFor(inputSecondURL.id) }



    document.querySelectorAll('input').forEach((input) => input.addEventListener('input', render))
    document.querySelectorAll('input').forEach((input) => input.addEventListener('change', render))
    document.querySelectorAll('input').forEach((input) => input.addEventListener('keyup', render))
    document.querySelectorAll('[data-force-imageload]').forEach((input) => input.addEventListener('change', loadImagesAndRender))
    document.querySelectorAll('[data-force-imageload]').forEach((input) => input.addEventListener('keyup', loadImagesAndRender))

    // UI Level toggle logic
    const setUiLevel = function (level) {
        const lvl = parseInt(level, 10) || 0
        document.body.dataset.uiLevel = String(lvl)
        document.querySelectorAll('.ui-level-0').forEach(function(el){ el.hidden = false })
        document.querySelectorAll('.ui-level-1, .ui-level-2').forEach(function(el){
            const required = el.classList.contains('ui-level-2') ? 2 : 1
            el.hidden = lvl < required
        })
        try { localStorage.setItem('uiLevel', String(lvl)) } catch(e) { }

        // In Simple mode, auto-expand Background prompt (P) and hide others via classes already
        try {
            if (typeof spanPromptBackground !== 'undefined') {
                spanPromptBackground.style.display = (lvl === 0) ? 'inline' : 'none'
            }
        } catch(e) { /* ignore */ }
    }
    if (typeof selectUiLevel !== 'undefined') {
        selectUiLevel.addEventListener('change', function(){ setUiLevel(this.value) })
        let stored = '0'
        try { stored = localStorage.getItem('uiLevel') || '0' } catch(e) { stored = '0' }
        selectUiLevel.value = stored
        setUiLevel(stored)
    }

    // --- Selection & Keyboard movement ---
    var selectedId = ''
    const clampNumberToRange = function(v, min, max){
        const n = parseFloat(v)
        const lo = parseFloat(min)
        const hi = parseFloat(max)
        return Math.max(lo, Math.min(hi, n))
    }
    const getTransformContainerById = function (id) {
        if (!id) return null
        if (id === inputBackgroundURL.id) return spanBackgroundPosition
        if (id === inputPose.id) return spanPosesPosition
        if (id === inputText1.id) return spanText1Position
        if (id === inputText2.id) return spanText2Position
        if (id === inputSecondURL.id) return spanSecondPosition
        if (id === inputThirdURL.id) return spanThirdPosition
        return null
    }
    const getSectionContainerById = function(id){
        const sub = getTransformContainerById(id)
        if (!sub) return null
        // Highlight the whole section container (panel)
        return sub.closest('.panel') || sub.closest('section') || sub.closest('div')
    }
    const clearSelectedUi = function(){
        document.querySelectorAll('.selectedControl').forEach(function(el){ el.classList.remove('selectedControl') })
        document.querySelectorAll('.selectedSection').forEach(function(el){ el.classList.remove('selectedSection') })
    }
    const setSelected = function(id){
        selectedId = id || ''
        clearSelectedUi()
        const cont = getTransformContainerById(selectedId)
        if (cont) { cont.classList.add('selectedControl') }
        const sec = getSectionContainerById(selectedId)
        if (sec) { sec.classList.add('selectedSection') }
        render()
    }
    const toggleSelect = function(id){
        if (!id) { setSelected(''); return }
        if (selectedId === id) { setSelected('') } else { setSelected(id) }
    }
    const adjustSelected = function(dx, dy){
        if (!selectedId) return
        const ix = eId('tf_' + selectedId + '_x')
        const iy = eId('tf_' + selectedId + '_y')
        if (!ix || !iy) return
        const stepx = dx
        const stepy = dy
        ix.value = clampNumberToRange(parseFloat(ix.value) + stepx, ix.min, ix.max)
        iy.value = clampNumberToRange(parseFloat(iy.value) + stepy, iy.min, iy.max)
        const nx = eId('tfn_' + selectedId + '_x')
        const ny = eId('tfn_' + selectedId + '_y')
        if (nx) nx.value = ix.value
        if (ny) ny.value = iy.value
        render()
    }
    const adjustRotationSelected = function(dRot){
        if (!selectedId) return
        const ir = eId('tf_' + selectedId + '_r')
        if (!ir) return
        ir.value = clampNumberToRange(parseFloat(ir.value) + dRot, ir.min, ir.max)
        const nr = eId('tfn_' + selectedId + '_r')
        if (nr) nr.value = ir.value
        render()
    }
    const adjustScaleSelected = function(dScale){
        if (!selectedId) return
        const is = eId('tf_' + selectedId + '_s')
        if (!is) return
        is.value = clampNumberToRange(parseFloat(is.value) + dScale, is.min, is.max)
        const ns = eId('tfn_' + selectedId + '_s')
        if (ns) ns.value = is.value
        render()
    }
    document.addEventListener('keydown', function(e){
        const k = e.key
        const moveStep = e.shiftKey ? 1 : 10
        const rotStep = e.shiftKey ? 1 : 5
        const sclStep = e.shiftKey ? 1 : 10
        const ae = document.activeElement
        if (ae && (ae.isContentEditable || (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.tagName === 'SELECT'))) { return }
        if (k === '1') { toggleSelect(inputBackgroundURL.id); return }
        if (k === '2') { toggleSelect(inputPose.id); return }
        if (k === '3') { toggleSelect(inputText1.id); return }
        if (k === '4') { toggleSelect(inputText2.id); return }
        if (k === '5') { toggleSelect(inputSecondURL.id); return }
        if (k === '6') { toggleSelect(inputThirdURL.id); return }
        if (k >= '0' && k <= '9') { setSelected(''); return }
        if (!selectedId) return
        if (k === 'ArrowLeft') { e.preventDefault(); adjustSelected(-moveStep, 0); return }
        if (k === 'ArrowRight') { e.preventDefault(); adjustSelected(moveStep, 0); return }
        if (k === 'ArrowUp') { e.preventDefault(); adjustSelected(0, -moveStep); return }
        if (k === 'ArrowDown') { e.preventDefault(); adjustSelected(0, moveStep); return }
        // WASD
        if (k === 'a' || k === 'A') { e.preventDefault(); adjustSelected(-moveStep, 0); return }
        if (k === 'd' || k === 'D') { e.preventDefault(); adjustSelected(moveStep, 0); return }
        if (k === 'w' || k === 'W') { e.preventDefault(); adjustSelected(0, -moveStep); return }
        if (k === 's' || k === 'S') { e.preventDefault(); adjustSelected(0, moveStep); return }
        // Rotation: Q/E
        if (k === 'q' || k === 'Q') { e.preventDefault(); adjustRotationSelected(-rotStep); return }
        if (k === 'e' || k === 'E') { e.preventDefault(); adjustRotationSelected(rotStep); return }
        // Scale: +/- (support Numpad + and - as well)
        if (k === '+' ) { e.preventDefault(); adjustScaleSelected(sclStep); return }
        if (k === '-') { e.preventDefault(); adjustScaleSelected(-sclStep); return }
        // Scale: R/F as alternative shortcuts
        if (k === 'r' || k === 'R') { e.preventDefault(); adjustScaleSelected(sclStep); return }
        if (k === 'f' || k === 'F') { e.preventDefault(); adjustScaleSelected(-sclStep); return }
    })

    // --- Canvas click selection (hit-testing and cycling front-to-back) ---
    const getTextSize = function(text){
        try {
            ctx.save()
            ctx.font = "64pt Impact"
            const m = ctx.measureText(text)
            const h = (m.actualBoundingBoxAscent || 40) + (m.actualBoundingBoxDescent || 10)
            const w = m.width || 0
            ctx.restore()
            return { w: w, h: h }
        } catch(e) {
            return { w: 0, h: 80 }
        }
    }
    const getLayersFrontToBack = function(){
        const layers = []
        // Front-most first in this list
        // Text2
        if (typeof inputText2 !== 'undefined') {
            const s = getTextSize(inputText2.value)
            layers.push({ kind:'text', id: inputText2.id, x: 50, y: canvas.height - 50, w: s.w, h: s.h, tl: false, align: 'start', baseline: 'bottom' })
        }
        // Text1
        if (typeof inputText1 !== 'undefined') {
            const s = getTextSize(inputText1.value)
            layers.push({ kind:'text', id: inputText1.id, x: canvas.width - 50, y: canvas.height - 50, w: s.w, h: s.h, tl: false, align: 'end', baseline: 'bottom' })
        }
        // SecondImage
        if (imgSecond) {
            layers.push({ kind:'image', id: inputSecondURL.id, x: 0, y: 0, w: imgSecond.width, h: imgSecond.height, tl: true })
        }
        // Pose
        if (imgPose) {
            const w = imgPoseWidth
            const source = (typeof chkPoseMask !== 'undefined' && chkPoseMask.checked && poseProcessedCanvas) ? poseProcessedCanvas : imgPose
            const h = w * source.height / source.width
            layers.push({ kind:'image', id: inputPose.id, x: canvas.width * 0.1, y: canvas.height * 0.3, w, h, tl: false })
        }
        // ThirdImage
        if (imgThird) {
            layers.push({ kind:'image', id: inputThirdURL.id, x: 0, y: 0, w: imgThird.width, h: imgThird.height, tl: false })
        }
        // Background
        if (imgBackground) {
            const w = Math.min(canvas.width, imgBackground.width)
            const h = w * imgBackground.height / imgBackground.width
            layers.push({ kind:'image', id: inputBackgroundURL.id, x: 0, y: 0, w, h, tl: false })
        }
        return layers
    }
    const getTransformForId = function(id){
        const tx = parseFloat((eId('tf_' + id + '_x') || { value: 0 }).value || 0)
        const ty = parseFloat((eId('tf_' + id + '_y') || { value: 0 }).value || 0)
        const r = parseFloat((eId('tf_' + id + '_r') || { value: 0 }).value || 0)
        const s = parseFloat((eId('tf_' + id + '_s') || { value: 100 }).value || 100) * 0.01
        const fh = (eId('tf_' + id + '_h') || { checked: false }).checked ? -1 : 1
        const fv = (eId('tf_' + id + '_v') || { checked: false }).checked ? -1 : 1
        return { tx, ty, r, s, fh, fv }
    }
    const rotatePoint = function(pt, angleRad){
        const c = Math.cos(angleRad), si = Math.sin(angleRad)
        return { x: pt.x * c - pt.y * si, y: pt.x * si + pt.y * c }
    }
    const worldToLocal = function(px, py, desc){
        // Inverse of forward chain:
        // pW = Tdesc ∘ Ttf ∘ [T(+w/2,+h/2) if !tl] ∘ R ∘ S ∘ Flip ∘ [T(-w/2,-h/2) if !tl] (pL)
        // pL = [T(+w/2,+h/2) if !tl]^{-1} ∘ Flip^{-1} ∘ S^{-1} ∘ R^{-1} ∘ [T(+w/2,+h/2) if !tl] ∘ Ttf^{-1} ∘ Tdesc^{-1} (pW)
        let p = { x: px, y: py }
        const tr = getTransformForId(desc.id)
        // Undo outer translations first
        p.x -= desc.x; p.y -= desc.y
        p.x -= tr.tx; p.y -= tr.ty
        if (!desc.tl) { p.x -= desc.w / 2; p.y -= desc.h / 2 }
        // Undo rotation
        p = rotatePoint(p, -tr.r * Math.PI / 180)
        // Undo scale
        if (tr.s !== 0) { p.x = p.x / tr.s; p.y = p.y / tr.s }
        // Undo flips
        p.x = p.x / tr.fh; p.y = p.y / tr.fv
        if (!desc.tl) { p.x += desc.w / 2; p.y += desc.h / 2 }
        return p
    }
    const isHit = function(px, py, desc){
        let lp = worldToLocal(px, py, desc)
        if (desc.kind === 'text') {
            let offX = 0, offY = 0
            if (desc.align === 'center') offX = -desc.w / 2
            else if (desc.align === 'end' || desc.align === 'right') offX = -desc.w
            else offX = 0
            if (desc.baseline === 'bottom' || desc.baseline === 'ideographic') offY = -desc.h
            else if (desc.baseline === 'middle') offY = -desc.h / 2
            else offY = 0
            lp = { x: lp.x - offX, y: lp.y - offY }
        }
        return lp.x >= 0 && lp.y >= 0 && lp.x <= desc.w && lp.y <= desc.h
    }
    let lastClickPos = null
    const getCanvasXY = function(evt){
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        return {
            x: (evt.clientX - rect.left) * scaleX,
            y: (evt.clientY - rect.top) * scaleY
        }
    }
    var dragState = null
    canvas.addEventListener('mousedown', function(e){
        const rect = canvas.getBoundingClientRect()
        const scaleX = canvas.width / rect.width
        const scaleY = canvas.height / rect.height
        const px = (e.clientX - rect.left) * scaleX
        const py = (e.clientY - rect.top) * scaleY
        const layers = getLayersFrontToBack()
        const hits = []
        for (let i = 0; i < layers.length; i++) {
            const d = layers[i]
            if (isHit(px, py, d)) { hits.push(d.id) }
        }
        if (e.button === 0) {
            if (!hits.length) {
                setSelected('')
                lastClickPos = { x: px, y: py }
                // still allow starting a drag move even with no selection
            } else {
                const same = lastClickPos && Math.abs(lastClickPos.x - px) < 3 && Math.abs(lastClickPos.y - py) < 3
                let nextIdx = 0
                if (same) {
                    const currentIdx = hits.indexOf(selectedId)
                    if (currentIdx >= 0) { nextIdx = (currentIdx + 1) % hits.length } else { nextIdx = 0 }
                }
                setSelected(hits[nextIdx])
                lastClickPos = { x: px, y: py }
            }
        } else if ((e.button === 1 || e.button === 2) && !selectedId && hits.length) {
            // If no selection, pick the topmost under cursor for MMB/RMB; otherwise keep selection
            setSelected(hits[0])
        }

        // Start drag depending on mouse button
        // 0: move, 2: rotate by y, 1: scale by y
        let mode = 'move'
        if (e.button === 2) mode = 'rotate'
        if (e.button === 1) mode = 'scale'
        dragState = { mode: mode, lastX: px, lastY: py }
        e.preventDefault()
    })
    const handleDragMove = function(e){
        if (!dragState || !selectedId) return
        const p = getCanvasXY(e)
        const dx = p.x - dragState.lastX
        const dy = p.y - dragState.lastY
        const fine = e.shiftKey ? 0.1 : 1
        if (dragState.mode === 'move') {
            adjustSelected(dx * fine, dy * fine)
        } else if (dragState.mode === 'rotate') {
            // Use both axes for smoother rotation control
            const rotDelta = (dx + dy) * (e.shiftKey ? 0.1 : 0.5)
            adjustRotationSelected(rotDelta)
        } else if (dragState.mode === 'scale') {
            adjustScaleSelected(-dy * (e.shiftKey ? 0.2 : 1))
        }
        dragState.lastX = p.x
        dragState.lastY = p.y
        e.preventDefault()
    }
    canvas.addEventListener('mousemove', handleDragMove)
    document.addEventListener('mousemove', handleDragMove)
    const endDrag = function(){ dragState = null }
    canvas.addEventListener('mouseup', endDrag)
    document.addEventListener('mouseup', endDrag)
    canvas.addEventListener('mouseleave', function(){ /* keep dragging across document for RMB/MMB */ })
    canvas.addEventListener('contextmenu', function(e){ e.preventDefault() })
    // Mouse wheel zoom
    canvas.addEventListener('wheel', function(e){
        if (!selectedId) return
        const factor = e.shiftKey ? 0.5 : 2
        const delta = -Math.sign(e.deltaY) * factor * 5
        adjustScaleSelected(delta)
        e.preventDefault()
    }, { passive: false })
    // Touch support (single finger = move)
    canvas.addEventListener('touchstart', function(e){
        if (!e.touches || e.touches.length < 1) return
        const t = e.touches[0]
        const p = getCanvasXY(t)
        dragState = { mode: 'move', lastX: p.x, lastY: p.y }
        // Do a quick hit-test to select something under finger if not already selected
        const layers = getLayersFrontToBack()
        for (let i = 0; i < layers.length; i++) {
            const d = layers[i]
            if (isHit(p.x, p.y, d)) { setSelected(d.id); break }
        }
        e.preventDefault()
    }, { passive: false })
    canvas.addEventListener('touchmove', function(e){
        if (!dragState || !selectedId || !e.touches || e.touches.length < 1) return
        const t = e.touches[0]
        const p = getCanvasXY(t)
        const dx = p.x - dragState.lastX
        const dy = p.y - dragState.lastY
        adjustSelected(dx, dy)
        dragState.lastX = p.x
        dragState.lastY = p.y
        e.preventDefault()
    }, { passive: false })
    canvas.addEventListener('touchend', function(){ dragState = null })
    canvas.addEventListener('touchcancel', function(){ dragState = null })
    // (Canvas focus gating removed)

    // download it

    btnDownload.addEventListener('click', function (e) {
        setSelected('')
        render()
        const canvasUrl = canvas.toDataURL('image/jpeg', 1.0)
        const fileName = buildDownloadFilename()
        const createEl = document.createElement('a')
        createEl.href = canvasUrl
        createEl.download = fileName
        createEl.click()
        createEl.remove()

        // Also persist result to backend (async, non-blocking)
        try {
            canvas.toBlob(function(blob){
                if (!blob) return
                const fd = new FormData()
                fd.append('action', 'save_result')
                fd.append('filename', fileName)
                // Serialize current inputs as JSON
                const params = collectCurrentParams()
                const obj = {}
                params.forEach((v, k) => { obj[k] = v })
                fd.append('settings', JSON.stringify({ params: obj, ts: new Date().toISOString() }))
                fd.append('image', blob, fileName)
                fetch('./assets.php', { method: 'POST', body: fd })
                    .then(r => r.json())
                    .then(() => { try { populateAssetLists() } catch(e){} })
                    .catch(() => { /* ignore */ })
            }, 'image/jpeg', 0.95)
        } catch(e) { /* ignore */ }
    })

    // Deletion of generated assets (one-by-one)
    function deleteGeneratedAsset(a, b, c) {
        try {
            // Support both signatures: (type, url) and (event, type, url)
            var evt = (typeof a === 'object' && a && typeof a.type === 'string') ? a : null;
            var type = (evt ? b : a);
            var url = (evt ? c : b);
            const parts = String(url || '').split('/');
            const fname = parts[parts.length - 1];
            if (!fname) { return; }
            const skipConfirm = !!(evt && evt.shiftKey);
            if (!skipConfirm && !confirm('Delete this ' + type + '?')) { return; }
            const body = 'action=delete&type=' + encodeURIComponent(type) + '&file=' + encodeURIComponent(fname)
            fetch('./assets.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body
            })
                .then(r => r.json())
                .then(res => {
                    if (res && res.success) {
                        // Clear current selection if it was the deleted one
                        if (type === 'pose' && (inputPoseURL.value || '').endsWith('/' + fname)) {
                            inputPoseURL.value = '';
                            inputPoseKeyColor.dataset.sampled = '';
                            loadImagesAndRender();
                        }
                        if (type === 'background' && (inputBackgroundURL.value || '').endsWith('/' + fname)) {
                            inputBackgroundURL.value = '';
                            loadImagesAndRender();
                        }
                        populateAssetLists();
                    } else {
                        alert('Delete failed');
                    }
                })
                .catch(() => alert('Delete failed'))
        } catch (e) { /* ignore */ }
    }

    // Restore a saved result's configuration
    function restoreResultSettings(jsonUrl){
        if (!jsonUrl) return
        fetch(jsonUrl)
            .then(r => r.json())
            .then(data => {
                try {
                    const params = (data && data.settings && data.settings.params) ? data.settings.params : (data && data.params ? data.params : null)
                    if (!params) return
                    document.querySelectorAll('input').forEach(function(input){
                        if (typeof params[input.id] === 'undefined') return
                        if (input.type === 'file') {
                            // ignore
                        } else if (input.type === 'checkbox') {
                            input.checked = String(params[input.id]) === 'true'
                        } else {
                            input.value = params[input.id]
                        }
                    })
                    syncAllTransformNumbers()
                    loadImagesAndRender()
                } catch(e) { /* ignore */ }
            })
            .catch(() => { /* ignore */ })
    }

</script>

<script src="theme.js"></script>

</html>